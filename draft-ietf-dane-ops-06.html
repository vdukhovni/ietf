<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Updates to and Operational Guidance for the DANE Protocol</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 DANE TLSA Record Overview"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Example TLSA record"/>
<link href="#rfc.section.3" rel="Chapter" title="3 DANE TLS Requirements"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Certificate-Usage-Specific DANE Updates and Guidelines"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Certificate Usage DANE-EE(3)"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Certificate Usage DANE-TA(2)"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Certificate Usage PKIX-EE(1)"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Certificate Usage PKIX-TA(0)"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Opportunistic Security and PKIX usages"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Service Provider and TLSA Publisher Synchronization"/>
<link href="#rfc.section.6" rel="Chapter" title="6 TLSA Base Domain and CNAMEs"/>
<link href="#rfc.section.7" rel="Chapter" title="7 TLSA Publisher Requirements"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Key rollover with fixed TLSA Parameters"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Switching to DANE-TA from DANE-EE"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Switching to New TLSA Parameters"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 TLSA Publisher Requirements Summary"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Digest Algorithm Agility"/>
<link href="#rfc.section.9" rel="Chapter" title="9 General DANE Guidelines"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 DANE DNS Record Size Guidelines"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Certificate Name Check Conventions"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Design Considerations for Protocols Using DANE"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Interaction with Certificate Transparency"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Note on DNSSEC Security"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Summary of Updates to RFC6698"/>
<link href="#rfc.section.13" rel="Chapter" title="13 Security Considerations"/>
<link href="#rfc.section.14" rel="Chapter" title="14 IANA Considerations"/>
<link href="#rfc.section.15" rel="Chapter" title="15 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="16 References"/>
<link href="#rfc.references.1" rel="Chapter" title="16.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="16.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.4.4 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Dukhovni, V. and W. Hardaker" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-dane-ops-06" />
  <meta name="dct.issued" scheme="ISO8601" content="2014-8-17" />
  <meta name="dct.abstract" content="This memo clarifies and updates the DANE TLSA protocol based on implementation experience since the publication of the original DANE specification in " />
  <meta name="description" content="This memo clarifies and updates the DANE TLSA protocol based on implementation experience since the publication of the original DANE specification in " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">DANE</td>
  <td class="right">V. Dukhovni</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Unaffiliated</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">W. Hardaker</td>
</tr>
<tr>
  <td class="left">Expires: February 18, 2015</td>
  <td class="right">Parsons</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">August 17, 2014</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Updates to and Operational Guidance for the DANE Protocol<br />
  <span class="filename">draft-ietf-dane-ops-06</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This memo clarifies and updates the DANE TLSA protocol based on implementation experience since the publication of the original DANE specification in <a href="#RFC6698">[RFC6698]</a>.  It also contains guidance for DANE implementers and operators.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on February 18, 2015.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2014 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>1.1.   <a href="#rfc.section.1.1">Terminology</a></li>
<li>2.   <a href="#rfc.section.2">DANE TLSA Record Overview</a></li>
<li>2.1.   <a href="#rfc.section.2.1">Example TLSA record</a></li>
<li>3.   <a href="#rfc.section.3">DANE TLS Requirements</a></li>
<li>4.   <a href="#rfc.section.4">Certificate-Usage-Specific DANE Updates and Guidelines</a></li>
<li>4.1.   <a href="#rfc.section.4.1">Certificate Usage DANE-EE(3)</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Certificate Usage DANE-TA(2)</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Certificate Usage PKIX-EE(1)</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Certificate Usage PKIX-TA(0)</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Opportunistic Security and PKIX usages</a></li>
<li>5.   <a href="#rfc.section.5">Service Provider and TLSA Publisher Synchronization</a></li>
<li>6.   <a href="#rfc.section.6">TLSA Base Domain and CNAMEs</a></li>
<li>7.   <a href="#rfc.section.7">TLSA Publisher Requirements</a></li>
<li>7.1.   <a href="#rfc.section.7.1">Key rollover with fixed TLSA Parameters</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Switching to DANE-TA from DANE-EE</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Switching to New TLSA Parameters</a></li>
<li>7.4.   <a href="#rfc.section.7.4">TLSA Publisher Requirements Summary</a></li>
<li>8.   <a href="#rfc.section.8">Digest Algorithm Agility</a></li>
<li>9.   <a href="#rfc.section.9">General DANE Guidelines</a></li>
<li>9.1.   <a href="#rfc.section.9.1">DANE DNS Record Size Guidelines</a></li>
<li>9.2.   <a href="#rfc.section.9.2">Certificate Name Check Conventions</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Design Considerations for Protocols Using DANE</a></li>
<li>10.   <a href="#rfc.section.10">Interaction with Certificate Transparency</a></li>
<li>11.   <a href="#rfc.section.11">Note on DNSSEC Security</a></li>
<li>12.   <a href="#rfc.section.12">Summary of Updates to RFC6698</a></li>
<li>13.   <a href="#rfc.section.13">Security Considerations</a></li>
<li>14.   <a href="#rfc.section.14">IANA Considerations</a></li>
<li>15.   <a href="#rfc.section.15">Acknowledgements</a></li>
<li>16.   <a href="#rfc.references">References</a></li>
<li>16.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>16.2.   <a href="#rfc.references.2">Informative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p><a href="#RFC6698">[RFC6698]</a> specifies a new DNS resource record "TLSA" that associates a public certificate or public key of a trusted leaf or issuing authority with the corresponding TLS transport endpoint.  These DANE TLSA records, when validated by DNSSEC, can be used to augment or replace the trust model of the existing public Certification Authority (CA) Public Key Infrastructure (PKI).  </p>
<p><a href="#RFC6698">[RFC6698]</a> defines three TLSA record fields with respectively 4, 2 and 3 currently specified values.  These yield 24 distinct combinations of TLSA record types.  This many options have lead to implementation and operational complexity.  This memo will recommend best-practice choices to help simplify implementation and deployment given these plethora of choices.  </p>
<p id="rfc.section.1.p.3">Implementation complexity also arises from the fact that the TLS transport endpoint is often specified indirectly via Service Records (SRV), Mail Exchange (MX) records, CNAME records or other mechanisms that map an abstract service domain to a concrete server domain.  With service indirection there are multiple potential places for clients to find the relevant TLSA records.  Service indirection is often used to implement "virtual hosting", where a single Service Provider transport endpoint simultaneously supports multiple hosted domain names.  With services that employ TLS, such hosting arrangements may require the Service Provider to deploy multiple pairs of private keys and certificates with TLS clients signaling the desired domain via the Server Name Indication (SNI) extension (<a href="#RFC6066">[RFC6066]</a>, section 3).  This memo provides operational guidelines intended to maximize interoperability between DANE TLS clients and servers.  </p>
<p id="rfc.section.1.p.4">In the context of this memo, channel security is assumed to be provided by TLS or DTLS.  The Transport Layer Security (TLS) <a href="#RFC5246">[RFC5246]</a> and Datagram Transport Layer Security (DTLS) <a href="#RFC6347">[RFC6347]</a> protocols provide secured TCP and UDP communication over IP.  By convention, "TLS" will be used throughout this document and, unless otherwise specified, the text applies equally well to the DTLS protocol.  Used without authentication, TLS provides protection only against eavesdropping through its use of encryption.  With authentication, TLS also provides integrity protection and authentication, which protect the transport against man-in-the-middle (MITM) attacks.  </p>
<p id="rfc.section.1.p.5">Other related documents that build on <a href="#RFC6698">[RFC6698]</a> are <a href="#I-D.ietf-dane-srv">[I-D.ietf-dane-srv]</a> and <a href="#I-D.ietf-dane-smtp-with-dane">[I-D.ietf-dane-smtp-with-dane]</a>.  In <a href="#updates">Section 12</a> we summarize the updates this document makes to <a href="#RFC6698">[RFC6698]</a>.  </p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> Terminology</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.  </p>
<p id="rfc.section.1.1.p.2">The following terms are used throughout this document: </p>

<dl>
  <dt>Service Provider:</dt>
  <dd style="margin-left: 8">A company or organization that offers to host a service on behalf of a Customer Domain.  The original domain name associated with the service often remains under the control of the customer.  Connecting applications may be directed to the Service Provider via a redirection resource record.  Example redirection records include MX, SRV, and CNAME.  The Service Provider frequently provides services for many customers and must carefully manage any TLS credentials offered to connecting applications to ensure name matching is handled easily by the applications.  </dd>
  <dt>Customer Domain:</dt>
  <dd style="margin-left: 8">As described above, a client may be interacting with a service that is hosted by a third party.  We will refer to the domain name used to locate the service prior to any redirection, as the "Customer Domain".  </dd>
  <dt>TLSA Publisher:</dt>
  <dd style="margin-left: 8">The entity responsible for publishing a TLSA record within a DNS zone.  This zone will be assumed DNSSEC-signed and validatable to a trust anchor, unless otherwise specified.  If the Customer Domain is not outsourcing their DNS service, the TLSA Publisher will be the customer themselves.  Otherwise, the TLSA Publisher is sometimes the operator of the outsourced DNS service.  </dd>
  <dt>public key:</dt>
  <dd style="margin-left: 8">The term "public key" is short-hand for the subjectPublicKeyInfo component of a PKIX <a href="#RFC5280">[RFC5280]</a> certificate.  </dd>
  <dt>SNI:</dt>
  <dd style="margin-left: 8">The "Server Name Indication" (SNI) TLS protocol extension allows a TLS client to request a connection to a particular service name of a TLS server (<a href="#RFC6066">[RFC6066]</a>, section 3).  Without this TLS extension, a TLS server has no choice but to offer a PKIX certificate with a default list of server names, making it difficult to host multiple Customer Domains at the same IP-addressed based TLS service endpoint (i.e., "secure virtual hosting").  </dd>
  <dt>TLSA parameters:</dt>
  <dd style="margin-left: 8">In <a href="#RFC6698">[RFC6698]</a> the TLSA record is defined to consist of four fields.  The first three of these are numeric parameters that specify the meaning of the data in fourth and final field.  To avoid language contortions when we need to distinguish between the first three fields that together define a TLSA record "type" and the fourth that provides a data value of that type, we will call the first three fields "TLSA parameters", or sometimes just "parameters" when obvious from context.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> DANE TLSA Record Overview</h1>
<p id="rfc.section.2.p.1">DANE TLSA <a href="#RFC6698">[RFC6698]</a> specifies a protocol for publishing TLS server certificate associations via DNSSEC <a href="#RFC4033">[RFC4033]</a> <a href="#RFC4034">[RFC4034]</a> <a href="#RFC4035">[RFC4035]</a>.  The DANE TLSA specification defines multiple TLSA RR types via combinations of numeric values of the first three fields of the TLSA record (i.e. the "TLSA parameters").  The numeric values of these parameters were later given symbolic names in <a href="#RFC7218">[RFC7218]</a>.  These parameters are: </p>
<p/>

<dl>
  <dt>The Certificate Usage field:</dt>
  <dd style="margin-left: 8">Section 2.1.1 of <a href="#RFC6698">[RFC6698]</a> specifies 4 values: PKIX-TA(0), PKIX-EE(1), DANE-TA(2), and DANE-EE(3).  There is an additional private-use value: PrivCert(255).  All other values are reserved for use by future specifications.  </dd>
  <dt>The selector field:</dt>
  <dd style="margin-left: 8">Section 2.1.2 of <a href="#RFC6698">[RFC6698]</a> specifies 2 values: Cert(0), SPKI(1).  There is an additional private-use value: PrivSel(255).  All other values are reserved for use by future specifications.  </dd>
  <dt>The matching type field:</dt>
  <dd style="margin-left: 8">Section 2.1.3 of <a href="#RFC6698">[RFC6698]</a> specifies 3 values: Full(0), SHA2-256(1), SHA2-512(2).  There is an additional private-use value: PrivMatch(255).  All other values are reserved for use by future specifications.  </dd>
</dl>

<p> </p>
<p id="rfc.section.2.p.3">We may think of TLSA Certificate Usage values 0 through 3 as a combination of two one-bit flags.  The low-bit chooses between trust anchor (TA) and end entity (EE) certificates.  The high bit chooses between PKIX, or public PKI issued, and DANE, or domain-issued trust anchors: </p>
<p/>

<ul>
  <li>When the low bit is set (PKIX-EE(1) and DANE-EE(3)) the TLSA record matches an EE certificate (also commonly referred to as a leaf or server certificate.)</li>
  <li>When the low bit is not set (PKIX-TA(0) and DANE-TA(2)) the TLSA record matches a trust anchor (a Certification Authority) that issued one of the certificates in the server certificate chain.  </li>
  <li>When the high bit is set (DANE-TA(2) and DANE-EE(3)), the server certificate chain is domain-issued and may be verified without reference to any pre-existing public certification authority PKI.  Trust is entirely placed on the content of the TLSA records obtained via DNSSEC.  </li>
  <li>When the high bit is not set (PKIX-TA(0) and PKIX-EE(1)), the TLSA record publishes a server policy stating that its certificate chain must pass PKIX validation <a href="#RFC5280">[RFC5280]</a> and the DANE TLSA record is used to signal an additional requirement that the PKIX validated server certificate chain also contains the referenced CA or EE certificate.  </li>
</ul>

<p> </p>
<p id="rfc.section.2.p.5">The selector field specifies whether the TLSA RR matches the whole certificate (Cert(0)) or just its subjectPublicKeyInfo (SPKI(1)).  The subjectPublicKeyInfo is an ASN.1 DER encoding of the certificate's algorithm id, any parameters and the public key data.  </p>
<p id="rfc.section.2.p.6">The matching type field specifies how the TLSA RR Certificate Association Data field is to be compared with the certificate or public key.  A value of Full(0) means an exact match: the full DER encoding of the certificate or public key is given in the TLSA RR.  A value of SHA2-256(1) means that the association data matches the SHA2-256 digest of the certificate or public key, and likewise SHA2-512(2) means a SHA2-512 digest is used.  Of the two digest algorithms, for now only SHA2-256(1) is mandatory to implement.  Clients SHOULD implement SHA2-512(2), but servers SHOULD NOT exclusively publish SHA2-512(2) digests.  The digest algorithm agility protocol defined in <a href="#agility">Section 8</a> SHOULD be used by clients to decide how to process TLSA RRsets that employ multiple digest algorithms.  Server operators MUST publish TLSA RRsets that are compatible with digest algorithm agility.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> Example TLSA record</h1>
<p id="rfc.section.2.1.p.1">In the example TLSA record below: </p>
<pre>
_25._tcp.mail.example.com. IN TLSA PKIX-TA Cert SHA2-256 (
                           E8B54E0B4BAA815B06D3462D65FBC7C0
                           CF556ECCF9F5303EBFBB77D022F834C0 )
    </pre>
<p id="rfc.section.2.1.p.2">The TLSA Certificate Usage is DANE-TA(2), the selector is Cert(0) and the matching type is SHA2-256(1).  The last field is the Certificate Association Data Field, which in this case contains the SHA2-256 digest of the server certificate.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#tlsreq" id="tlsreq">DANE TLS Requirements</a></h1>
<p><a href="#RFC6698">[RFC6698]</a> does not discuss what versions of TLS are required when using DANE records.  This document specifies that TLS clients that support DANE/TLSA MUST support at least TLS 1.0 and SHOULD support TLS 1.2.  TLS clients and servers using DANE SHOULD support the "Server Name Indication" (SNI) extension of TLS.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> Certificate-Usage-Specific DANE Updates and Guidelines</h1>
<p id="rfc.section.4.p.1">The four Certificate Usage values from the TLSA record, DANE-EE(3), DANE-TA(2), PKIX-EE(1) and PKIX-TA(0), are discussed below.  </p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#type3" id="type3">Certificate Usage DANE-EE(3)</a></h1>
<p id="rfc.section.4.1.p.1">In this section the meaning of DANE-EE(3) is updated from <a href="#RFC6698">[RFC6698]</a> to specify that peer identity matching and that validity interval compliance is based solely on the TLSA RRset properties.  We also extend <a href="#RFC6698">[RFC6698]</a> to cover the use of DANE authentication of raw public keys <a href="#I-D.ietf-tls-oob-pubkey">[I-D.ietf-tls-oob-pubkey]</a> via TLSA records with Certificate Usage DANE-EE(3) and selector SPKI(1).  </p>
<p id="rfc.section.4.1.p.2">Authentication via certificate usage DANE-EE(3) TLSA records involves simply checking that the server's leaf certificate matches the TLSA record.  In particular, the binding of the server public key to its name is based entirely on the TLSA record association.  The server MUST be considered authenticated even if none of the names in the certificate match the client's reference identity for the server.  </p>
<p id="rfc.section.4.1.p.3">Similarly, with DANE-EE(3), the expiration date of the server certificate MUST be ignored. The validity period of the TLSA record key binding is determined by the validity interval of the TLSA record DNSSEC signatures.  </p>
<p id="rfc.section.4.1.p.4">With DANE-EE(3) servers that know all the connecting clients are making use of DANE, they need not employ SNI (i.e., the may ignore the client's SNI message) even when the server is known under multiple domain names that would otherwise require separate certificates.  It is instead sufficient for the TLSA RRsets for all the domain names in question to match the server's primary certificate.  For application protocols where the server name is obtained indirectly via SRV, MX or similar records, it is simplest to publish a single hostname as the target server name for all the hosted domains.  </p>
<p id="rfc.section.4.1.p.5">In organizations where it is practical to make coordinated changes in DNS TLSA records before server key rotation, it is generally best to publish end-entity DANE-EE(3) certificate associations in preference to other choices of certificate usage.  DANE-EE(3) TLSA records support multiple server names without SNI, don't suddenly stop working when leaf or intermediate certificates expire, and don't fail when a server operator neglects to include all the required issuer certificates in the server certificate chain.  </p>
<p id="rfc.section.4.1.p.6">TLSA records published for DANE servers SHOULD, as a best practice, be "DANE-EE(3) SPKI(1) SHA2-256(1)" records.  Since all DANE implementations are required to support SHA2-256, this record type works for all clients and need not change across certificate renewals with the same key.  This TLSA record type easily supports hosting arrangements with a single certificate matching all hosted domains.  It is also the easiest to implement correctly in the client.  </p>
<p id="rfc.section.4.1.p.7">Another advantage of "DANE-EE(3) SPKI(1)" (with any suitable matching type) TLSA records is that they are compatible with the raw public key TLS extension specified in <a href="#I-D.ietf-tls-oob-pubkey">[I-D.ietf-tls-oob-pubkey]</a>.  DANE clients that support this extension can use the TLSA record to authenticate servers that negotiate the use of raw public keys in place of X.509 certificate chains.  Provided the server adheres to the requirements of <a href="#rrreq">Section 7</a>, the fact that raw public keys are not compatible with any other TLSA record types will not get in the way of successful authentication.  Clients that employ DANE to authenticate the peer server SHOULD NOT negotiate the use of raw public keys unless the server's TLSA RRset includes compatible TLSA records.  </p>
<p id="rfc.section.4.1.p.8">While it is, in principle, also possible to authenticate raw public keys via "DANE-EE(3) Cert(0) Full(0)" records by extracting the public key from the certificate in DNS, this is in conflict with the indicated selector and requires extra logic on clients that not all implementations are expected to provide.  Servers SHOULD NOT rely on "DANE-EE(3) Cert(0) Full(0)" TLSA records to publish authentication data for raw public keys.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#type2" id="type2">Certificate Usage DANE-TA(2)</a></h1>
<p id="rfc.section.4.2.p.1">This section updates <a href="#RFC6698">[RFC6698]</a> by specifying a new operational requirement for servers publishing TLSA records with a usage of DANE-TA(2): such servers MUST include the trust-anchor certificate in their TLS server certificate message.  </p>
<p id="rfc.section.4.2.p.2">Some domains may prefer to avoid the operational complexity of publishing unique TLSA RRs for each TLS service.  If the domain employs a common issuing Certification Authority to create certificates for multiple TLS services, it may be simpler to publish the issuing authority as a trust anchor (TA) for the certificate chains of all relevant services.  The TLSA query domain (TLSA base domain with port and protocol prefix labels) for each service issued by the same TA may then be set to a CNAME alias that points to a common TLSA RRset that matches the TA.  For example: </p>
<pre>
www1.example.com.            IN A 192.0.2.1
www2.example.com.            IN A 192.0.2.2
_443._tcp.www1.example.com.  IN CNAME tlsa201._dane.example.com.
_443._tcp.www2.example.com.  IN CNAME tlsa201._dane.example.com.
tlsa201._dane.example.com.   IN TLSA 2 0 1 e3b0c44298fc1c14...
      </pre>
<p id="rfc.section.4.2.p.3">With usage DANE-TA(2) the server certificates will need to have names that match one of the client's reference identifiers (see <a href="#RFC6125">[RFC6125]</a>).  The server SHOULD employ SNI to select the appropriate certificate to present to the client.  </p>
<h1 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> Recommended record combinations</h1>
<p id="rfc.section.4.2.1.p.1">TLSA records with selector Full(0) are NOT RECOMMENDED.  While these potentially obviate the need to transmit the TA certificate in the TLS server certificate message, client implementations may not be able to augment the server certificate chain with the data obtained from DNS, especially when the TLSA record supplies a bare key (selector SPKI(1)).  Since the server will need to transmit the TA certificate in any case, server operators SHOULD publish TLSA records with a selector other than Full(0) and avoid potential DNS interoperability issues with large TLSA records containing full certificates or keys (see <a href="#sizeissues">Section 9.1.1</a>).  </p>
<p id="rfc.section.4.2.1.p.2">TLSA Publishers employing DANE-TA(2) records SHOULD publish records with a selector of Cert(0).  Such TLSA records are associated with the whole trust anchor certificate, not just with the trust anchor public key.  In particular, the client SHOULD then apply any relevant constraints from the trust anchor certificate, such as, for example, path length constraints.  </p>
<p id="rfc.section.4.2.1.p.3">While a selector of SPKI(1) may also be employed, the resulting TLSA record will not specify the full trust anchor certificate content, and elements of the trust anchor certificate other than the public key become mutable.  This may, for example, enable a subsidiary CA to issue a chain that violates the trust anchor's path length or name constraints.  </p>
<h1 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> Trust anchor digests and server certificate chain</h1>
<p id="rfc.section.4.2.2.p.1">With DANE-TA(2) (these TLSA records are expected to match the digest of a TA certificate or public key), a complication arises when the TA certificate is omitted from the server's certificate chain, perhaps on the basis of Section 7.4.2 of <a href="#RFC5246">[RFC5246]</a>: </p>
<pre>
The sender's certificate MUST come first in the list.  Each
following certificate MUST directly certify the one preceding
it.  Because certificate validation requires that root keys be
distributed independently, the self-signed certificate that
specifies the root certification authority MAY be omitted from
the chain, under the assumption that the remote end must
already possess it in order to validate it in any case.
	</pre>
<p id="rfc.section.4.2.2.p.2">With TLSA Certificate Usage DANE-TA(2), there is no expectation that the client is pre-configured with the trust anchor certificate.  In fact, client implementations are free to ignore all locally configured trust anchors when processing usage DANE-TA(2) TLSA records and may rely exclusively on the certificates provided in the server's certificate chain.  But, with a digest in the TLSA record, the TLSA record contains neither the full trust anchor certificate nor the full public key.  If the TLS server's certificate chain does not contain the trust anchor certificate, DANE clients will be unable to authenticate the server.  </p>
<p id="rfc.section.4.2.2.p.3">TLSA Publishers that publish TLSA Certificate Usage DANE-TA(2) associations with a selector of SPKI(1) or using a digest-based matching type (not Full(0)) MUST ensure that the corresponding server is configured to also include the trust anchor certificate in its TLS handshake certificate chain, even if that certificate is a self-signed root CA and would have been optional in the context of the existing public CA PKI.  </p>
<h1 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a> Trust anchor public keys</h1>
<p id="rfc.section.4.2.3.p.1">TLSA records with TLSA Certificate Usage DANE-TA(2), selector SPKI(1) and a matching type of Full(0) will publish the full public key of a trust anchor via DNS.  In section 6.1.1 of <a href="#RFC5280">[RFC5280]</a> the definition of a trust anchor consists of the following four parts: </p>
<p/>

<ol>
  <li>the trusted issuer name,</li>
  <li>the trusted public key algorithm,</li>
  <li>the trusted public key, and</li>
  <li>optionally, the trusted public key parameters associated with the public key.</li>
</ol>
<p id="rfc.section.4.2.3.p.3">Items 2&#8211;4 are precisely the contents of the subjectPublicKeyInfo published in the TLSA record.  The issuer name is not included in the subjectPublicKeyInfo.  </p>
<p id="rfc.section.4.2.3.p.4">With TLSA Certificate Usage DANE-TA(2), the client may not have the associated trust anchor certificate, and cannot generally verify whether a particular certificate chain is "issued by" the trust anchor described in the TLSA record.  </p>
<p id="rfc.section.4.2.3.p.5">When the server certificate chain includes a CA certificate whose public key matches the TLSA record, the client can match that CA as the intended issuer.  Otherwise, the client can only check that the topmost certificate in the server's chain is "signed by" the trust anchor's public key in the TLSA record.  Such a check may be difficult to implement, and cannot be expected to be supported by all clients.  </p>
<p id="rfc.section.4.2.3.p.6">Thus, servers should not rely on "DANE-TA(2) SPKI(1) Full(0)" TLSA records to be sufficient to authenticate chains issued by the associated public key in the absence of a corresponding certificate in the server's TLS certificate message.  Servers SHOULD include the TA certificate in their certificate chain.  </p>
<p id="rfc.section.4.2.3.p.7">If none of the server's certificate chain elements match a public key specified in a TLSA record, and at least one "DANE-TA(2) SPKI(1) Full(0)" TLSA record is available, clients are encouraged to check whether the topmost certificate in the chain is signed by the provided public key and has not expired, and in that case consider the server authenticated, provided the rest of the chain passes validation including leaf certificate name checks.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#type1" id="type1">Certificate Usage PKIX-EE(1)</a></h1>
<p id="rfc.section.4.3.p.1">This Certificate Usage is similar to DANE-EE(3), but in addition PKIX verification is required.  Therefore, name checks, certificate expiration, etc., apply as they would without DANE.  When, for a given application protocol, DANE clients support both DANE-EE(3) and PKIX-EE(1) usages, it should be noted that an attacker who can compromise DNSSEC can replace these with usage DANE-EE(3) or DANE-TA(2) TLSA records of their choosing, and thus bypass any PKIX verification requirements.  </p>
<p id="rfc.section.4.3.p.2">Therefore, except when applications support only the PKIX Certificate Usages (0 and 1), this Certificate Usage offers only illusory incremental security over usage DANE-EE(3).  It provides lower operational reliability than DANE-EE(3) since some clients may not be configured with the required root CA, the server's chain may be incomplete or name checks may fail.  PKIX-EE(1) also requires more complex coordination between the Customer Domain and the Service Provider in hosting arrangements.  This certificate usage is NOT RECOMMENDED.  </p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#type0" id="type0">Certificate Usage PKIX-TA(0)</a></h1>
<p id="rfc.section.4.4.p.1">This section updates <a href="#RFC6698">[RFC6698]</a> by specifying new client implementation requirements.  Clients that trust intermediate certificates MUST be prepared to construct longer PKIX chains than would be required for PKIX alone.  </p>
<p id="rfc.section.4.4.p.2">TLSA Certificate Usage PKIX-TA(0) allows a domain to publish constraints on the set of PKIX certification authorities trusted to issue certificates for its TLS servers.  This TLSA record matches PKIX-verified trust chains which contain an issuer certificate (root or intermediate) that matches its association data field (typically a certificate or digest).  </p>
<p id="rfc.section.4.4.p.3">As with PKIX-EE(1) case, an attacker who can compromise DNSSEC can replace these with usage DANE-EE(3) or DANE-TA(2) TLSA records of his choosing and thus bypass the PKIX verification requirements.  Therefore, except when applications support only the PKIX Certificate Usages (0 and 1), this Certificate Usage offers only illusory incremental security over usage DANE-TA(2).  It provides lower operational reliability than DANE-TA(2) since some clients may not be configured with the required root CA.  PKIX-TA(0) also requires more complex coordination between the Customer Domain and the Service Provider in hosting arrangements.  This certificate usage is NOT RECOMMENDED.  </p>
<p id="rfc.section.4.4.p.4">TLSA Publishers who publish TLSA records for a particular public root CA, will expect that clients will then only accept chains anchored at that root.  It is possible, however, that the client's trusted certificate store includes some intermediate CAs, either with or without the corresponding root CA.  When a client constructs a trust chain leading from a trusted intermediate CA to the server leaf certificate, such a "truncated" chain might not contain the trusted root published in the server's TLSA record.  </p>
<p id="rfc.section.4.4.p.5">If the omitted root is also trusted, the client may erroneously reject the server chain if it fails to determine that the shorter chain it constructed extends to a longer trusted chain that matches the TLSA record.  Thus, when matching a usage PKIX-TA(0) TLSA record, a client SHOULD NOT always stop extending the chain when the first locally trusted certificate is found.  If no TLSA records have matched any of the elements of the chain, and the trusted certificate found is not self-issued, the client MUST attempt to build a longer chain in the hope that a certificate closer to the root may in fact match the server's TLSA record.  </p>
<h1 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> Opportunistic Security and PKIX usages</h1>
<p id="rfc.section.4.5.p.1">When the client's protocol design is based on Opportunistic Security (OS, <a href="#I-D.dukhovni-opportunistic-security">[I-D.dukhovni-opportunistic-security]</a>), and authentication is opportunistically employed based on the presence of server TLSA records, it is especially important to avoid the PKIX-EE(1) and PKIX-TA(0) certificate usages.  This is because the client has no way to know in advance that it and the server both trust the requisite root CA.  Use of authentication in OS needs to be employed only when the client can be confident of success, absent an attack, or an operational error on the server side.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#sync" id="sync">Service Provider and TLSA Publisher Synchronization</a></h1>
<p id="rfc.section.5.p.1">Complications arise when the TLSA Publisher is not the same entity as the Service Provider.  In this situation, the TLSA Publisher and the Service Provider must cooperate to ensure that TLSA records published by the TLSA Publisher don't fall out of sync with the server certificate used by the Service Provider.  </p>
<p id="rfc.section.5.p.2">Whenever possible, the TLSA Publisher and the Service Provider should be the same entity.  Otherwise, changes in the service certificate chain must be carefully coordinated between the parties involved.  Such coordination is difficult and service outages will result when coordination fails.  </p>
<p id="rfc.section.5.p.3">Having the master TLSA record in the Service Provider's zone avoids the complexity of bilateral coordination of server certificate configuration and TLSA record management.  Even when the TLSA RRset must be published in the Customer Domain's DNS zone (perhaps the client application does not "chase" CNAMEs to the TLSA base domain), it is possible to employ CNAME records to delegate the content of the TLSA RRset to a domain operated by the Service Provider.  Certificate name checks generally constrain the applicability of TLSA CNAMEs across organizational boundaries to Certificate Usages DANE-EE(3) and DANE-TA(2): </p>
<p/>

<dl>
  <dt>Certificate Usage DANE-EE(3):</dt>
  <dd style="margin-left: 8">In this case the Service Provider can publish a single TLSA RRset that matches the server certificate or public key digest.  The same RRset works for all Customer Domains because name checks do not apply with DANE-EE(3) TLSA records (see <a href="#type3">Section 4.1</a>).  A Customer Domain can create a CNAME record pointing to the TLSA RRset published by the Service Provider.  </dd>
  <dt>Certificate Usage DANE-TA(2):</dt>
  <dd style="margin-left: 8">When the Service Provider operates a private certification authority, the Service Provider is free to issue a certificate bearing any customer's domain name.  Without DANE, such a certificate would not pass trust verification, but with DANE, the customer's TLSA RRset that is aliased to the provider's TLSA RRset can delegate authority to the provider's CA for the corresponding service.  The Service Provider can generate appropriate certificates for each customer and use the SNI information provided by clients to select the right certificate chain to present to each client.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.p.5">Below are example DNS records (assumed "secure" and shown without the associated DNSSEC information, such as record signatures) that illustrate both of of the above models in the case of an HTTPS service whose clients all support DANE TLS.  These examples work even with clients that don't "chase" CNAMEs when constructing the TLSA base domain (see <a href="#cname">Section 6</a> below).  </p>
<pre>
; The hosted web service is redirected via a CNAME alias.
; The associated TLSA RRset is also redirected via a CNAME alias.
;
; A single certificate at the provider works for all Customer
; Domains due to the use of the DANE-EE(3) Certificate Usage.
;
www1.example.com.            IN CNAME w1.example.net.
_443._tcp.www1.example.com.  IN CNAME _443._tcp.w1.example.net.
_443._tcp.w1.example.net.    IN TLSA DANE-EE SPKI SHA2-256 (
                                8A9A70596E869BED72C69D97A8895DFA
                                D86F300A343FECEFF19E89C27C896BC9 )

;
; A CA at the provider can also issue certificates for each Customer
; Domain, and use the DANE-TA(2) Certificate Usage type to
; indicate a trust anchor.
;
www2.example.com.            IN CNAME w2.example.net.
_443._tcp.www2.example.com.  IN CNAME _443._tcp.w2.example.net.
_443._tcp.w2.example.net.    IN TLSA DANE-TA Cert SHA2-256 (
                                C164B2C3F36D068D42A6138E446152F5
                                68615F28C69BD96A73E354CAC88ED00C )
  </pre>
<p id="rfc.section.5.p.6">With protocols that support explicit transport redirection via DNS MX records, SRV records, or other similar records, the TLSA base domain is based on the redirected transport end-point, rather than the origin domain.  With SMTP, for example, when an email service is hosted by a Service Provider, the Customer Domain's MX hostnames will point at the Service Provider's SMTP hosts.  When the Customer Domain's DNS zone is signed, the MX hostnames can be securely used as the base domains for TLSA records that are published and managed by the Service Provider.  For example (without the required DNSSEC information, such as record signatures): </p>
<pre>
; Hosted SMTP service
;
example.com.               IN MX 0 mx1.example.net.
example.com.               IN MX 0 mx2.example.net.
_25._tcp.mx1.example.net.  IN TLSA DANE-EE SPKI SHA2-256 (
                              8A9A70596E869BED72C69D97A8895DFA
                              D86F300A343FECEFF19E89C27C896BC9 )
_25._tcp.mx2.example.net.  IN TLSA DANE-EE SPKI SHA2-256 (
                              C164B2C3F36D068D42A6138E446152F5
                              68615F28C69BD96A73E354CAC88ED00C )
  </pre>
<p id="rfc.section.5.p.7">If redirection to the Service Provider's domain (via MX or SRV records or any similar mechanism) is not possible, and aliasing of the TLSA record is not an option, then more complex coordination between the Customer Domain and Service Provider will be required.  Either the Customer Domain periodically provides private keys and a corresponding certificate chain to the Provider (after making appropriate changes in its TLSA records), or the Service Provider periodically generates the keys and certificates and must wait for matching TLSA records to be published by its Customer Domains before deploying newly generated keys and certificate chains.  In <a href="#cname">Section 6</a> below, we describe an approach that employs CNAME "chasing" to avoid the difficulties of coordinating key management across organization boundaries.  </p>
<p id="rfc.section.5.p.8">For further information about combining DANE and SRV, please see <a href="#I-D.ietf-dane-srv">[I-D.ietf-dane-srv]</a>.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#cname" id="cname">TLSA Base Domain and CNAMEs</a></h1>
<p id="rfc.section.6.p.1">When the application protocol does not support service location indirection via MX, SRV or similar DNS records, the service may be redirected via a CNAME.  A CNAME is a more blunt instrument for this purpose, since unlike an MX or SRV record, it remaps the entire origin domain to the target domain for all protocols.  </p>
<p id="rfc.section.6.p.2">The complexity of coordinating key management is largely eliminated when DANE TLSA records are found in the Service Provider's domain, as discussed in <a href="#sync">Section 5</a>.  Therefore, DANE TLS clients connecting to a server whose domain name is a CNAME alias SHOULD follow the CNAME hop-by-hop to its ultimate target host (noting at each step whether the CNAME is DNSSEC-validated).  If at each stage of CNAME expansion the DNSSEC validation status is "secure", the final target name SHOULD be the preferred base domain for TLSA lookups.  </p>
<p id="rfc.section.6.p.3">Implementations failing to find a TLSA record using a base name of the final target of a CNAME expansion SHOULD issue a TLSA query using the original destination name.  That is, the preferred TLSA base domain should be derived from the fully expanded name, and failing that should be the initial domain name.  </p>
<p id="rfc.section.6.p.4">When the TLSA base domain is the result of "secure" CNAME expansion, the resulting domain name MUST be used as the HostName in SNI, and MUST be the primary reference identifier for peer certificate matching with certificate usages other than DANE-EE(3).  </p>
<p id="rfc.section.6.p.5">Protocol-specific TLSA specifications may provide additional guidance or restrictions when following CNAME expansions.  </p>
<p id="rfc.section.6.p.6">Though CNAMEs are illegal on the right hand side of most indirection records, such as MX and SRV records, they are supported by some implementations.  For example, if the MX or SRV host is a CNAME alias, some implementations may "chase" the CNAME.  If they do, they SHOULD use the target hostname as the preferred TLSA base domain as described above (and if the TLSA records are found there, use the CNAME expanded domain also in SNI and certificate name checks).  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#rrreq" id="rrreq">TLSA Publisher Requirements</a></h1>
<p id="rfc.section.7.p.1">This section updates <a href="#RFC6698">[RFC6698]</a> by specifying a requirement on the TLSA Publisher to ensure that each combination of Certificate Usage, selector and matching type in the server's TLSA RRset MUST include at least one record that matches the server's current certificate chain.  TLSA records that match recently retired or yet to be deployed certificate chains will be present during key rollover.  Such past or future records must never be the only records published for any given combination of usage, selector and matching type.  We describe a TLSA record update algorithm that ensures this requirement is met.  </p>
<p id="rfc.section.7.p.2">While a server is to be considered authenticated when its certificate chain is matched by any of the published TLSA records, not all clients support all combinations of TLSA record parameters.  Some clients may not support some digest algorithms, others may either not support, or may exclusively support, the PKIX Certificate Usages.  Some clients may prefer to negotiate <a href="#I-D.ietf-tls-oob-pubkey">[I-D.ietf-tls-oob-pubkey]</a> raw public keys, which are only compatible with TLSA records whose Certificat Usage is DANE-EE(3) with selector SPKI(1).  </p>
<p id="rfc.section.7.p.3">A consequence of the above uncertainty as to which TLSA parameters are supported by any given client is that servers need to ensure that each and every parameter combination that appears in the TLSA RRset is, on its own, sufficient to match the server's current certificate chain.  In particular, when deploying new keys or new parameter combinations some care is required to not generate parameter combinations that only match past or future certificate chains (or raw public keys).  The rest of this section explains how to update the TLSA RRset in a manner that ensures the above requirement is met.  </p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#rollkey" id="rollkey">Key rollover with fixed TLSA Parameters</a></h1>
<p id="rfc.section.7.1.p.1">The simplest case is key rollover while retaining the same set of published parameter combinations.  In this case, TLSA records matching the existing server certificate chain (or raw public keys) are first augmented with corresponding records matching the future keys, at least two TTLs or longer before the the new chain is deployed.  This allows the obsolete RRset to age out of client caches before the new chain is used in TLS handshakes.  Once sufficient time has elapsed and all clients performing DNS lookups are retrieving the updated TLSA records, the server administrator may deploy the new certificate chain, verify that it works, and then remove any obsolete records matching the no longer active chain: </p>
<pre>
; The initial TLSA RRset
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...

; The transitional TLSA RRset published at least 2*TTL seconds
; before the actual key change
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...

; The final TLSA RRset after the key change
;
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...
    </pre>
<p id="rfc.section.7.1.p.2">The next case to consider is adding or switching to a new combination of TLSA parameters.  In this case publish the new parameter combinations for the server's existing certificate chain first, and only then deploy new keys if desired: </p>
<pre>
; Initial TLSA RRset
;
_443._tcp.www.example.org. IN TLSA 1 1 1 01d09d19c2139a46...

; New TLSA RRset, same key re-published as DANE-EE(3)
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
    </pre>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Switching to DANE-TA from DANE-EE</h1>
<p id="rfc.section.7.2.p.1">A more complex involves switching to a trust-anchor or PKIX usage from a chain that is either self-signed, or issued by a private CA and thus not compatible with PKIX.  Here the process is to first add TLSA records matching the future chain that is issued by the desired future CA (private or PKIX), but initially with the same parameters as the legacy chain.  Then, after deploying the new keys, switch to the new TLSA parameter combination.  </p>
<pre>
; The initial TLSA RRset
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...

; A transitional TLSA RRset, published at least 2*TTL before the
; actual key change.  The new keys are issued by a DANE-TA(2) CA, 
; but for now specified via a DANE-EE(3) association.
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...

; The final TLSA RRset after the key change.  Now that the old
; self-signed EE keys are not an impediment, specify the issuing
; TA of the new keys.
;
_443._tcp.www.example.org. IN TLSA 2 0 1 c57bce38455d9e3d...
    </pre>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> Switching to New TLSA Parameters</h1>
<p id="rfc.section.7.3.p.1">When employing a new digest algorithm in the TLSA RRset, for compatibility with digest agility specified in <a href="#agility">Section 8</a> below, administrators should publish the new digest algorithm with each combinations of Certificate Usage and selector for each associated key or chain used with any other digest algorithm.  When removing an algorithm, remove it entirely.  Each digest algorithm employed should match the same set of chains (or raw public keys).  </p>
<pre>
; The initial TLSA RRset with EE SHA2-256 associations for two keys.
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...

; The new TLSA RRset also with SHA2-512 associations for each key
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 2 d9947c35089310bc...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...
_443._tcp.www.example.org. IN TLSA 3 1 2 89a7486a4b6ae714...
    </pre>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> TLSA Publisher Requirements Summary</h1>
<p id="rfc.section.7.4.p.1">In summary, server operators updating TLSA records should make one change at a time.  The individual safe changes are: </p>

<ul>
  <li>Pre-publish new certificate associations that employ the same TLSA parameters (usage, selector and matching type) as existing TLSA records, but match certificate chains that will be deployed in the near future.  Wait for stale TLSA RRsets to expire from DNS caches before configuring servers to use the new certificate chain. </li>
  <li>Remove TLSA records matching no longer deployed certificate chains. </li>
  <li>Extend the TLSA RRset with a new combination of parameters (usage, selector and matching type) that is used to generate matching associations for all certificate chains that are published with some other parameter combination. </li>
</ul>

<p> The above steps are intended to ensure that at all times and for each combination of usage, selector and matching type at least one TLSA record corresponds to the server's current certificate chain.  No combination of Certificate Usage, selector and matching type in a server's TLSA RRset should ever match only some combination of future or past certificate chains.  As a result, no matter what combinations of usage, selector and matching type may be supported by a given client, they will be sufficient to authenticate the server.  </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#agility" id="agility">Digest Algorithm Agility</a></h1>
<p id="rfc.section.8.p.1">While <a href="#RFC6698">[RFC6698]</a> specifies multiple digest algorithms, it does not specify a protocol by which the TLS client and TLSA record publisher can agree on the strongest shared algorithm.  Such a protocol would allow the client and server to avoid exposure to any deprecated weaker algorithms that are published for compatibility with less capable clients, but should be ignored when possible.  We specify such a protocol below.  </p>
<p id="rfc.section.8.p.2">Suppose that a DANE TLS client authenticating a TLS server considers digest algorithm "BetterAlg" stronger than digest algorithm "WorseAlg".  Suppose further that a server's TLSA RRset contains some records with "BetterAlg" as the digest algorithm.  Suppose also that the server adheres to the requirements of <a href="#rrreq">Section 7</a> and ensures that each combination of TLSA parameters contains at least one record that matches the server's current certificate chain (or raw public keys).  Under the above assumptions the client can safely ignore TLSA records with the weaker algorithm "WorseAlg", because it suffices to only check the records with the stronger algorithm "BetterAlg".  </p>
<p id="rfc.section.8.p.3">To make digest algorithm agility possible, all published TLSA RRsets for use with DANE TLS MUST conform to the requirements of <a href="#rrreq">Section 7</a>.  With servers publishing compliant TLSA RRsets, TLS clients can, for each combination of usage and selector, ignore all digest records except those that employ their notion of the strongest digest algorithm.  (The server should only publish algorithms it deems acceptable at all.)  The ordering of digest algorithms by strength is not specified in advance; it is entirely up to the TLS client.  TLS client implementations SHOULD make the digest algorithm preference ordering a configurable option.  </p>
<p id="rfc.section.8.p.4">Note, TLSA records with a matching type of Full(0) that publish an entire certificate or public key object play no role in digest algorithm agility.  They neither trump the processing of records that employ digests, nor are they ignored in the presence of any records with a digest (i.e. non-zero) matching type.  </p>
<p id="rfc.section.8.p.5">TLS clients SHOULD use digest algorithm agility when processing the DANE TLSA records of an TLS server.  Algorithm agility is to be applied after first discarding any unusable or malformed records (unsupported digest algorithm, or incorrect digest length).  Thus, for each usage and selector, the client SHOULD process only any usable records with a matching type of Full(0) and the usable records whose digest algorithm is considered by the client to be the strongest among usable records with the given usage and selector.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> General DANE Guidelines</h1>
<p id="rfc.section.9.p.1">These guidelines provide guidance for using or designing protocols for DANE.  </p>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#dns" id="dns">DANE DNS Record Size Guidelines</a></h1>
<p id="rfc.section.9.1.p.1">Selecting a combination of TLSA parameters to use requires careful thought.  One important consideration to take into account is the size of the resulting TLSA record after its parameters are selected.  </p>
<h1 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a> <a href="#sizeissues" id="sizeissues">UDP and TCP Considerations</a></h1>
<p id="rfc.section.9.1.1.p.1">Deployments SHOULD avoid TLSA record sizes that cause UDP fragmentation.  </p>
<p id="rfc.section.9.1.1.p.2">Although DNS over TCP would provide the ability to more easily transfer larger DNS records between clients and servers, it is not universally deployed and is still prohibited by some firewalls.  Clients that request DNS records via UDP typically only use TCP upon receipt of a truncated response in the DNS response message sent over UDP.  Setting the TC bit alone will be insufficient if the response containing the TC bit is itself fragmented.  </p>
<h1 id="rfc.section.9.1.2"><a href="#rfc.section.9.1.2">9.1.2.</a> Packet Size Considerations for TLSA Parameters</h1>
<p id="rfc.section.9.1.2.p.1">Server operators SHOULD NOT publish TLSA records using both a TLSA Selector of Cert(0) and a TLSA Matching Type of Full(0), as even a single certificate is generally too large to be reliably delivered via DNS over UDP.  Furthermore, two TLSA records containing full certificates will need to be published simultaneously during a certificate rollover, as discussed in <a href="#rollkey">Section 7.1</a>.  </p>
<p id="rfc.section.9.1.2.p.2">While TLSA records using a TLSA Selector of SPKI(1) and a TLSA Matching Type of Full(0) (which publish the bare public keys without the overhead of a containing X.509 certificate) are generally more compact, these too should be used with caution as they are still larger than necessary.  Rather, servers SHOULD publish digest-based TLSA Matching Types in their TLSA records.  The complete corresponding certificate should, instead, be transmitted to the client in-band during the TLS handshake, which can be easily verified using the digest value.  </p>
<p id="rfc.section.9.1.2.p.3">In summary, the use of a TLSA Matching Type of Full(0) is NOT RECOMMENDED and the use of a digest-based matching type, such as SHA2-256(1) SHOULD be used.  </p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#namechecks" id="namechecks">Certificate Name Check Conventions</a></h1>
<p id="rfc.section.9.2.p.1">Certificates presented by a TLS server will generally contain a subjectAltName (SAN) extension or a Common Name (CN) element within the subject distinguished name (DN).  The TLS server's DNS domain name is normally published within these elements, ideally within the subjectAltName extension. (The use of the CN field for this purpose is deprecated.) </p>
<p id="rfc.section.9.2.p.2">When a server hosts multiple domains at the same transport endpoint, the server's ability to respond with the right certificate chain is predicated on correct SNI information from the client.  DANE clients MUST send the SNI extension with a HostName value of the base domain of the TLSA RRset.  </p>
<p id="rfc.section.9.2.p.3">Except with TLSA Certificate Usage DANE-EE(3), where name checks are not applicable (see <a href="#type3">Section 4.1</a>), DANE clients MUST verify that the client has reached the correct server by checking that the server name is listed in the server certificate's SAN or CN.  The server name used for this comparison SHOULD be the base domain of the TLSA RRset.  Additional acceptable names may be specified by protocol-specific DANE standards.  For example, with SMTP both the destination domain name and the MX host name are acceptable names to be found in the server certificate (see <a href="#I-D.ietf-dane-smtp-with-dane">[I-D.ietf-dane-smtp-with-dane]</a>).  </p>
<p id="rfc.section.9.2.p.4">It is the responsibility of the service operator, in coordination with the TLSA Publisher, to ensure that at least one of the TLSA records published for the service will match the server's certificate chain (either the default chain or the certificate that was selected based on the SNI information provided by the client).  </p>
<p id="rfc.section.9.2.p.5">Given the DNSSEC validated DNS records below: </p>
<pre>
example.com.               IN MX 0 mail.example.com.
mail.example.com.          IN A 192.0.2.1
_25._tcp.mail.example.com. IN TLSA DANE-TA Cert SHA2-256  (
                              E8B54E0B4BAA815B06D3462D65FBC7C0
                              CF556ECCF9F5303EBFBB77D022F834C0 )
      </pre>
<p id="rfc.section.9.2.p.6">The TLSA base domain is "mail.example.com" and is required to be the HostName in the client's SNI extension.  The server certificate chain is required to be be signed by a trust anchor with the above certificate SHA2-256 digest.  Finally, one of the DNS names in the server certificate is required to be be either "mail.example.com" or "example.com" (this additional name is a concession to compatibility with prior practice, see <a href="#I-D.ietf-dane-smtp-with-dane">[I-D.ietf-dane-smtp-with-dane]</a> for details).  </p>
<p id="rfc.section.9.2.p.7">The semantics of wildcards in server certificates are left to individual application protocol specifications.  </p>
<h1 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> Design Considerations for Protocols Using DANE</h1>
<p id="rfc.section.9.3.p.1">When a TLS client goes to the trouble of authenticating a certificate chain presented by a TLS server, it will typically not continue to use that server in the event of authentication failure, or else authentication serves no purpose.  Some clients may, at times, operate in an "audit" mode, where authentication failure is reported to the user or in logs as a potential problem, but the connection proceeds despite the failure.  Nevertheless servers publishing TLSA records MUST be configured to allow correctly configured clients to successfully authenticate their TLS certificate chains.  </p>
<p id="rfc.section.9.3.p.2">A service with DNSSEC-validated TLSA records implicitly promises TLS support.  When all the TLSA records for a service are found "unusable", due to unsupported parameter combinations or malformed associated data, DANE clients cannot authenticate the service certificate chain.  When authenticated TLS is dictated by the application, the client SHOULD NOT connect to the associated server.  If, on the other hand, the use of TLS is "opportunistic", then the client SHOULD generally use the server via an unauthenticated TLS connection, but if TLS encryption cannot be established, the client MUST NOT use the server.  Standards for DANE specific to the particular application protocol may modify the above requirements, as appropriate, to specify whether the connection should be established anyway without relying on TLS security, with only encryption but not authentication, or whether to refuse to connect entirely.  Application protocols need to specify when to prioritize security over the ability to connect under adverse conditions.  </p>
<h1 id="rfc.section.9.3.1"><a href="#rfc.section.9.3.1">9.3.1.</a> <a href="#nopki" id="nopki">Design Considerations for non-PKIX Protocols</a></h1>
<p id="rfc.section.9.3.1.p.1">For some application protocols (such as SMTP to MX with opportunistic TLS), the existing public CA PKI is not a viable alternative to DANE.  For these (non-PKIX) protocols, new DANE standards SHOULD NOT suggest publishing TLSA records with TLSA Certificate Usage PKIX-TA(0) or PKIX-EE(1), as TLS clients cannot be expected to perform <a href="#RFC5280">[RFC5280]</a> PKIX validation or <a href="#RFC6125">[RFC6125]</a> identity verification.  </p>
<p id="rfc.section.9.3.1.p.2">Protocols designed for non-PKIX use SHOULD choose to treat any TLSA records with TLSA Certificate Usage PKIX-TA(0) or PKIX-EE(1) as unusable.  After verifying that the only available TLSA Certificate Usage types are PKIX-TA(0) or PKIX-EE(1), protocol specifications MAY instruct clients to either refuse to initiate a connection or to connect via unauthenticated TLS if no alternative authentication mechanisms are available.  </p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> Interaction with Certificate Transparency</h1>
<p id="rfc.section.10.p.1">Certificate Transparency (CT) <a href="#RFC6962">[RFC6962]</a> defines an experimental approach to mitigate the risk of rogue or compromised public CAs issuing unauthorized certificates.  This section clarifies the interaction of CT and DANE.  CT is an experimental protocol and auditing system that applies only to public CAs, and only when they are free to issue unauthorized certificates for a domain.  If the CA is not a public CA, or a DANE-EE(3) TLSA RR directly specifies the end entity certificate, there is no role for CT, and clients need not apply CT checks.  </p>
<p id="rfc.section.10.p.2">When a server is authenticated via a DANE TLSA RR with TLSA Certificate Usage DANE-EE(3), the domain owner has directly specified the certificate associated with the given service without reference to any PKIX certification authority.  Therefore, when a TLS client authenticates the TLS server via a TLSA certificate association with usage DANE-EE(3), CT checks SHOULD NOT be performed.  Publication of the server certificate or public key (digest) in a TLSA record in a DNSSEC signed zone by the domain owner assures the TLS client that the certificate is not an unauthorized certificate issued by a rogue CA without the domain owner's consent.  </p>
<p id="rfc.section.10.p.3">When a server is authenticated via a DANE TLSA RR with TLSA usage DANE-TA(2) and the server certificate does not chain to a known public root CA, CT cannot apply (CT logs only accept chains that start with a known, public root).  Since TLSA Certificate Usage DANE-TA(2) is generally intended to support non-PKIX trust anchors, TLS clients SHOULD NOT perform CT checks with usage DANE-TA(2) using unknown root CAs.  </p>
<p id="rfc.section.10.p.4">A server operator who wants clients to perform CT checks should publish TLSA RRs with usage PKIX-TA(0) or PKIX-EE(1).  </p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> Note on DNSSEC Security</h1>
<p id="rfc.section.11.p.1">Clearly the security of the DANE TLSA PKI rests on the security of the underlying DNSSEC infrastructure.  While this memo is not a guide to DNSSEC security, a few comments may be helpful to TLSA implementers.  </p>
<p id="rfc.section.11.p.2">With the existing public CA PKI, name constraints are rarely used, and a public root CA can issue certificates for any domain of its choice.  With DNSSEC, under the Registry/Registrar/Registrant model, the situation is different: only the registrar of record can update a domain's DS record in the registry parent zone (in some cases, however, the registry is the sole registrar).  With many gTLDs, for which multiple registrars compete to provide domains in a single registry, it is important to make sure that rogue registrars cannot easily initiate an unauthorized domain transfer, and thus take over DNSSEC for the domain.  DNS Operators SHOULD use a registrar lock of their domains to offer some protection against this possibility.  </p>
<p id="rfc.section.11.p.3">When the registrar is also the DNS operator for the domain, one needs to consider whether the registrar will allow orderly migration of the domain to another registrar or DNS operator in a way that will maintain DNSSEC integrity.  TLSA Publishers SHOULD ensure their registrar publishes a suitable domain transfer policy.  </p>
<p id="rfc.section.11.p.4">DNSSEC signed RRsets cannot be securely revoked before they expire.  Operators should plan accordingly and not generate signatures with excessively long duration periods.  For domains publishing high-value keys, a signature lifetime of a few days is reasonable, and the zone should be resigned daily.  For domains with less critical data, a reasonable signature lifetime is a couple of weeks to a month, and the zone should be resigned weekly.  Monitoring of the signature lifetime is important.  If the zone is not resigned in a timely manner, one risks a major outage and the entire domain will become bogus.  </p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#updates" id="updates">Summary of Updates to RFC6698</a></h1>
<p id="rfc.section.12.p.1">Authors note: is this section needed?  Or is it sufficiently clear above that we don't need to restate things here?</p>
<p/>

<ul>
  <li>In <a href="#tlsreq">Section 3</a> we update <a href="#RFC6698">[RFC6698]</a> to specify a requirement for clients to support at least TLS 1.0, and to support SNI. </li>
  <li>In <a href="#type3">Section 4.1</a> we update <a href="#RFC6698">[RFC6698]</a> to specify peer identity matching and certificate validity interval based solely on the basis of the TLSA RRset.  We also specify DANE authentication of raw public keys <a href="#I-D.ietf-tls-oob-pubkey">[I-D.ietf-tls-oob-pubkey]</a> via TLSA records with Certificate Usage DANE-EE(3) and selector SPKI(1). </li>
  <li>In <a href="#type2">Section 4.2</a> we update <a href="#RFC6698">[RFC6698]</a> to require that servers publishing digest TLSA records with a usage of DANE-TA(2) MUST include the trust-anchor certificate in their TLS server certificate message.  This extends to the case of "2 1 0" TLSA records which publish a full public key. </li>
  <li>In <a href="#type1">Section 4.3</a> and <a href="#type0">Section 4.4</a>, we explain that PKIX-EE(1) and PKIX-TA(0) are generally NOT RECOMMENDED.  With usage PKIX-TA(0) we note that clients may need to processes extended trust chains beyond the first trusted issuer, when that issuer is not self-signed. </li>
  <li>In <a href="#cname">Section 6</a>, we recommend that DANE application protocols specify that when possible securely CNAME expanded names be used to derive the TLSA base domain. </li>
  <li>In <a href="#rrreq">Section 7</a>, we specify a strategy for managing TLSA records that interoperates with DANE clients regardless of what subset of the possible TLSA record types (combinations of TLSA parameters) is supported by the client. </li>
  <li>In <a href="#agility">Section 8</a>, we propose a digest algorithm agility protocol.  [Note: This section does not yet represent the rough consensus of the DANE working group and requires further discussion.  Perhaps this belongs in a separate document.] </li>
  <li>In <a href="#dns">Section 9.1</a> we recommend against the use of Full(0) TLSA records, as digest records are generally much more compact. </li>
</ul>

<p> </p>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#Security" id="Security">Security Considerations</a></h1>
<p id="rfc.section.13.p.1">Application protocols that cannot make use of the existing public CA PKI (so called non-PKIX protocols), may choose not to implement certain PKIX-dependent TLSA record types defined in <a href="#RFC6698">[RFC6698]</a>.  If such records are published despite not being supported by the application protocol, they are treated as "unusable".  When TLS is opportunistic, the client may proceed to use the server with mandatory unauthenticated TLS.  This is stronger than opportunistic TLS without DANE, since in that case the client may also proceed with a plaintext connection.  When TLS is not opportunistic, the client MUST NOT connect to the server.  </p>
<p id="rfc.section.13.p.2">Therefore, when TLSA records are used with protocols where PKIX does not apply, the recommended policy is for servers to not publish PKIX-dependent TLSA records, and for opportunistic TLS clients to use them to enforce the use of (albeit unauthenticated) TLS, but otherwise treat them as unusable.  Of course, when PKIX validation is supported by the application protocol, clients SHOULD perform PKIX validation per <a href="#RFC6698">[RFC6698]</a>.  </p>
<h1 id="rfc.section.14"><a href="#rfc.section.14">14.</a> IANA Considerations</h1>
<p id="rfc.section.14.p.1">This specification requires no support from IANA.</p>
<h1 id="rfc.section.15"><a href="#rfc.section.15">15.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.15.p.1">The authors would like to thank Phil Pennock for his comments and advice on this document.  </p>
<p id="rfc.section.15.p.2">Acknowledgments from Viktor: Thanks to Tony Finch who finally prodded me into participating in DANE working group discussions.  Thanks to Paul Hoffman who motivated me to produce this memo and provided feedback on early drafts.  Thanks also to Samuel Dukhovni for editorial assistance.  </p>
<h1 id="rfc.references"><a href="#rfc.references">16.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">16.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4033">[RFC4033]</b>
      </td>
      <td class="top"><a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>", RFC 4033, March 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4034">[RFC4034]</b>
      </td>
      <td class="top"><a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>", RFC 4034, March 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4035">[RFC4035]</b>
      </td>
      <td class="top"><a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4035">Protocol Modifications for the DNS Security Extensions</a>", RFC 4035, March 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6066">[RFC6066]</b>
      </td>
      <td class="top"><a>Eastlake, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, January 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6125">[RFC6125]</b>
      </td>
      <td class="top"><a>Saint-Andre, P.</a> and <a>J. Hodges</a>, "<a href="http://tools.ietf.org/html/rfc6125">Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</a>", RFC 6125, March 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6698">[RFC6698]</b>
      </td>
      <td class="top"><a>Hoffman, P.</a> and <a>J. Schlyter</a>, "<a href="http://tools.ietf.org/html/rfc6698">The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA</a>", RFC 6698, August 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7218">[RFC7218]</b>
      </td>
      <td class="top"><a>Gudmundsson, O.</a>, "<a href="http://tools.ietf.org/html/rfc7218">Adding Acronyms to Simplify Conversations about DNS-Based Authentication of Named Entities (DANE)</a>", RFC 7218, April 2014.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">16.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.dukhovni-opportunistic-security">[I-D.dukhovni-opportunistic-security]</b>
      </td>
      <td class="top"><a>Dukhovni, V.</a>, "<a href="http://tools.ietf.org/html/draft-dukhovni-opportunistic-security-03">Opportunistic Security: Some Protection Most of the Time</a>", Internet-Draft draft-dukhovni-opportunistic-security-03, August 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-dane-smtp-with-dane">[I-D.ietf-dane-smtp-with-dane]</b>
      </td>
      <td class="top"><a>Dukhovni, V.</a> and <a>W. Hardaker</a>, "<a href="http://tools.ietf.org/html/draft-ietf-dane-smtp-with-dane-11">SMTP security via opportunistic DANE TLS</a>", Internet-Draft draft-ietf-dane-smtp-with-dane-11, August 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-dane-srv">[I-D.ietf-dane-srv]</b>
      </td>
      <td class="top"><a>Finch, T.</a>, <a>Miller, M.</a> and <a>P. Saint-Andre</a>, "<a href="http://tools.ietf.org/html/draft-ietf-dane-srv-07">Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records</a>", Internet-Draft draft-ietf-dane-srv-07, July 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-oob-pubkey">[I-D.ietf-tls-oob-pubkey]</b>
      </td>
      <td class="top"><a>Wouters, P.</a>, <a>Tschofenig, H.</a>, <a>Gilmore, J.</a>, <a>Weiler, S.</a> and <a>T. Kivinen</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-oob-pubkey-11">Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", Internet-Draft draft-ietf-tls-oob-pubkey-11, January 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6962">[RFC6962]</b>
      </td>
      <td class="top"><a>Laurie, B.</a>, <a>Langley, A.</a> and <a>E. Kasper</a>, "<a href="http://tools.ietf.org/html/rfc6962">Certificate Transparency</a>", RFC 6962, June 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Viktor Dukhovni</span> 
	  <span class="n hidden">
		<span class="family-name">Dukhovni</span>
	  </span>
	</span>
	<span class="org vcardline">Unaffiliated</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf-dane@dukhovni.org">ietf-dane@dukhovni.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Wes Hardaker</span> 
	  <span class="n hidden">
		<span class="family-name">Hardaker</span>
	  </span>
	</span>
	<span class="org vcardline">Parsons</span>
	<span class="adr">
	  <span class="vcardline">P.O. Box 382</span>

	  <span class="vcardline">
		<span class="locality">Davis</span>,  
		<span class="region">CA</span> 
		<span class="code">95617</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@hardakers.net">ietf@hardakers.net</a></span>

  </address>
</div>

</body>
</html>
