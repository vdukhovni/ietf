<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4033 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4033.xml">
<!ENTITY RFC4034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY RFC4035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY RFC4346 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC6066 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY RFC6125 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6698 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6698.xml">
<!ENTITY RFC6962 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6962.xml">
<!ENTITY I-D.ietf-dane-srv SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-srv.xml">
<!ENTITY I-D.ietf-dane-smtp-with-dane SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-smtp-with-dane.xml">
<!ENTITY I-D.ietf-dane-registry-acronyms SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-registry-acronyms.xml">
]>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="bcp" docName="draft-ietf-dane-ops-02" ipr="trust200902">

<front>
<title abbrev="DANE operations">DANE TLSA implementation and operational guidance</title>
<author fullname="Viktor Dukhovni" initials="V." surname="Dukhovni">
<organization>Unaffiliated</organization>
<address>
<email>ietf-dane@dukhovni.org</email>
</address>
</author>
    <author initials="W.H." surname="Hardaker" fullname="Wes Hardaker">
      <organization>Parsons</organization>
      <address>
        <postal>
          <street>P.O. Box 382</street>
          <city>Davis</city>
          <region>CA</region>
          <code>95617</code>
          <country>US</country>
        </postal>
        <email>ietf@hardakers.net</email>
      </address>
    </author>
<date month="January" year="2014" />
<area>sec</area>
<workgroup>DANE</workgroup>
<keyword>DANE</keyword>
<keyword>TLSA</keyword>

<abstract>

<t>
This memo provides guidance to server operators to help
ensure that clients will be able to authenticate a server's
certificate chain via published TLSA records.  Guidance is also
provided to clients for selecting reliable TLSA record parameters and
how to use them for server authentication.  Finally, guidance is given to
protocol designers who wish to make use of TLSA records when securing
protocols using a TLS and TLSA combination.
</t>

</abstract>

</front>

<middle>
<section title="Introduction">

<t>
Section 2 of <xref target="RFC6698"/> specifies a new "TLSA" DNS resource
record which associates with a TLS transport endpoint the corresponding
trusted leaf or issuing authority certificates or public keys.  DNSSEC
validated DANE TLSA records can be used to augment or replace the trust
model of the existing public CA PKI.
</t>

<t>
<xref target="RFC6698"/> defines 24 combinations of TLSA record parameters.
Additional complexity arises when the TLS transport endpoint is obtained
indirectly via SRV, MX and CNAME records or other mechanisms that map an
abstract service domain to a concrete server domain.  With service
indirection there are multiple potential places for clients to find the
relevant TLSA records.  Service indirection is often used to implement
"virtual hosting", where a single service provider transport endpoint
simultaneously supports multiple hosted domains.  With services that employ
TLS, such hosting arrangements may require the service provider to employ
multiple pairs of private keys and certificates with TLS clients signalling
the desired domain via SNI (<xref target="RFC6066" />, section 3).  This
memo provides operational guidelines intended to maximize interoperability
between DANE TLS clients and servers.
</t>

<t>
In the context of this memo, channel security is assumed to be provided by
TLS or DTLS.  The Transport Layer Security (TLS) and Datagram Transport
Layer Security (DTLS) protocols provide secured TCP and UDP communication
over the Internet Protocol.  By convention, "TLS" will be used throughout
this document and, unless otherwise specified, the text applies equally
well to the DTLS protocol.  Used without authentication, TLS provides
protection only against eavesdropping.  With authentication, TLS also
provides protection against man-in-the-middle (MITM) attacks.
</t>

<section title="Terminology">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
this document are to be interpreted as described in <xref
target="RFC2119"/>.
</t>

<t>The following terms are used throughout this document:
<list style="hanging">
  <t hangText="Service Provider:">
    A company or organization that offers to host a service on behalf
    of a Customer Domain.  The original domain name associated with the
    service often remains under the control of the customer.  Connecting
    applications are directed to the service provider via a redirection
    resource record.  Example redirection records include MX, SRV, and
    CNAME.  The Service Provider typically provides services for
    many customers and must carefully manage any TLS credentials
    offered to connecting applications to ensure name matching is
    handled easily by the applications.
  </t>
  <t hangText="Customer Domain:">
    Customers that make use of a Service Provider to outsource their
    services will be referred to as "Customer Domains".
  </t>
  <t hangText="TLSA Publisher:">
    The entity responsible for publishing a TLSA record within a DNS
    zone.  This zone will be considered DNSSEC signed and validatable
    to a trust anchor, unless otherwise specified.  If the Customer
    Domain is not outsourcing their DNS service, the TLSA Publisher
    will be the customer themselves.  Otherwise the TLSA Publisher may
    be the operator of the outsourced DNS service.
  </t>
  <t hangText="public key:">
    The term "public key" will be an informal short-hand for the
    subjectPublicKeyInfo component of a PKIX certificate.
  </t>
  <t hangText="SNI:">
    "Server Name Indication", or SNI, describes the TLS protocol
    extension by which a TLS client requests to connect to a
    particular service name of a TLS server (<xref target="RFC6066"
    />, section 3).  Without this TLS extension, a TLS server has no choice
    but to offer a PKIX certificate with a default list of server
    names making it difficult to host multiple customer domains at
    the same TLS service endpoint (secure virtual hosting).
  </t>
</list>
</t>

</section><!-- Terminology -->

</section><!-- Introduction -->

<section title="DANE TLSA record overview">
<t>
DANE TLSA <xref target="RFC6698"/> specifies a protocol for publishing
TLS server certificate associations via DNSSEC.  The DANE TLSA
specification defines multiple TLSA RR types via combinations of 3
numeric parameters.  The numeric values of these parameters were
later given symbolic names in <xref target="I-D.ietf-dane-registry-acronyms"/>. 
These parameters are:
</t>

<t>
<list style='hanging'>

<t hangText="The TLSA Certificate Usage field:"> Section 2.1.1 of
<xref target="RFC6698"/> specifies 4 values: PKIX-TA(0), PKIX-EE(1),
DANE-TA(2), and DANE-EE(3).  There is an additional private-use
value: PrivCert(255).  All other values are reserved for use by
future specifications.  </t>

<t hangText="The selector field:"> Section 2.1.2 of <xref
target="RFC6698"/> specifies 2 values: Cert(0), SPKI(1).  There is
an additional private-use value: PrivSel(255).  All other values
are reserved for use by future specifications.  </t>

<t hangText="The matching type field:"> Section 2.1.3 of <xref
target="RFC6698"/> specifies 3 values: Full(0), SHA2-256(1),
SHA2-512(2).  There is an additional private-use value: PrivMatch(255).
All other values are reserved for use by future specifications.  </t>

</list>
</t>

<t>
We may think of TLSA Certificate Usage values 0 through 3 to
be a combination of two one-bit flags.  The low-bit chooses between
trust-anchor (TA) and end-entity (EE) certificates.  The high bit
chooses between public PKI issued and domain-issued certificates:
</t>

<t>
<list style="symbols">

<t>
When the low bit is set (PKIX-EE(1) and DANE-EE(3)) the TLSA record
matches an EE (commonly referred to as a leaf or server) certificate.
</t>

<t>
When the low bit is not set (PKIX-TA(0) and DANE-TA(2)) the TLSA
record matches a trust-anchor (a certificate authority) that issued
one of the certificates in the server certificate chain.
</t>

<t>
When the high bit is set (DANE-TA(2) and DANE-EE(3)), the server
certificate chain is domain-issued and may be verified without
reference to any pre-existing public certificate authority PKI.  Trust is
entirely placed on the content of the TLSA records obtained via
DNSSEC.
</t>

<t>
When the high bit is not set (PKIX-CA(0) and PKIX-EE(1)), the TLSA
record publishes a server policy stating that its certificate
chain must pass PKIX validation <xref target="RFC5280"/> and the
DANE TLSA record is used to constrain the server certificate chain to
contain the referenced CA or EE certificate.
</t>

</list>
</t>

<t>
The selector field specifies whether the TLSA RR matches the whole
certificate (Cert(0)) or just its subjectPublicKeyInfo (SPKI(1)).  The
subjectPublicKeyInfo is an ASN.1 DER encoding of the certificate's
algorithm id, any parameters and the public key data).
</t>

<t>
The matching type field specifies how the TLSA RR Certificate
Association Data field is to be compared with the certificate or
public key.  A value of Full(0) means an exact match: the full DER
encoding of the certificate or public key is given in the TLSA RR.
A value of SHA2-256(1) means that the association data matches the
SHA-256 digest of the certificate or public key, and likewise
SHA-512(2) means a SHA-512 digest is used.  Of the two digest
algorithms, for now only SHA-256(1) is mandatory to implement.
Clients SHOULD implement SHA-512(2), but servers SHOULD NOT exclusively
publish SHA-512(2) digests.  
<!-- XXX: Add reference to digest agility -->
</t>

<section title="Example TLSA record">
<t>
In the example TLSA record below:
</t>

<figure>
<artwork>
  _25._tcp.mail.example.com. IN TLSA 2 0 1 (
                                E8B54E0B4BAA815B06D3462D65FBC7C0
                                CF556ECCF9F5303EBFBB77D022F834C0 )
</artwork>
</figure>

<t>
The TLSA Certificate Usage is DANE-TA(2), the selector is Cert(0)
and the matching type is SHA2-256(1).  The rest of the record is the
certificate association data field, which is in this case the SHA2-256
digest of the server certificate.
</t>
</section><!-- Example TLSA record -->

</section><!-- DANE TLSA record overview -->

<section title="General DANE Guidelines">
  <t>These guidelines provide guidance for using or designing
  protocols for DANE, regardless of what of TLSA record will
  be used.</t>
  <section title="TLS Requirements">
    <t>TLS clients that support DANE/TLSA MUST support at least TLS 1.0 and
    SHOULD support TLS 1.2.  TLS clients and servers using DANE SHOULD
    support the "Server Name Indication" extension of TLS.</t>
  </section>
  <section title="DANE DNS Record Size Guidelines">
    <t>
      Selecting a combination of TLSA parameters to use requires
      careful thought.  One important consideration to take into
      account is the size of the resulting TLSA record after
      its parameters are selected.
    </t>
    <section title="UDP and TCP Considerations">

      <t>
	Deployments SHOULD avoid TLSA record sizes that cause UDP
	fragmentation.
      </t>
      <t>
	Although DNS over TCP would provide the ability to transfer
	larger DNS records between clients and servers, it is not
	universally deployed and is still blocked by some firewalls.
	Clients that request DNS records via UDP typically only
	use TCP upon receipt of a truncated response in TCP.
        <!-- WJH: recommend removal of the rest of this; I don't think
        it's needed and barely scratches the surface of the problem
        space and is thus incomplete.  All we really want to say is
        "don't use UDP because it casues problems, and the above does
        that already"  -->
        <!-- UDP responses in excess
	of the MTU may be generated without truncation, but may fail
	to be delivered when intermediate network equipment does not
	fully support UDP fragmentation.  Thus, requests for large
	RRsets may time out without a TCP retry. -->
      </t>
    </section>
    <section title= "Packet Size Considerations for TLSA Parameters">
      <t>
	Server operators SHOULD NOT publish TLSA records using both a
        TLSA Selector of Cert(0) and a TLSA Matching Type of Full(0),
        as even a single certificate is generally too large to be
        reliably delivered via DNS over UDP.  Furthermore, two TLSA
        records containing full certificates may need to be published
        in during certificate rollover.
      </t>

      <t>
	While TLSA records using a TLSA Selector of SPKI(1) and a TLSA
	Matching Type of Full(0) publish full public keys without the
	full X.509 wrapping, are generally more compact, these too
	should be used with caution as they are still larger than
	necessary.  Rather, servers SHOULD make use of the
	digest-based TLSA Matching Types within TLSA records.
	The complete corresponding certificate should, instead, be
	transmitted to the client in-band during the TLS handshake.
      </t>

      <t>In summary, the use of a TLSA Matching Type of Full(0) is NOT
      RECOMMENDED and the use of SHA-256(1) and SHA-512(2) is strongly
      preferred. </t>
    </section>
  </section>

  <section title="Certificate Name Check Conventions">

    <t>
      Certificates presented by a TLS server will generally contain
      a Common Name (CN) element in the subject distinguished name
      (DN) and/or a subjectAltName (SAN) extension.  The server's
      DNS hostname should be published within these elements, ideally
      within the subjectAltName extension as use of the CN field
      for this purpose is deprecated.  Name checks SHOULD ONLY
      consider the subject CN when no SAN values of type 'dns' are
      present.
    </t>

    <t>
      When a server hosts multiple domains at the same transport
      endpoint, the server's ability to respond with the right
      certificate chain is predicated on correct SNI information
      from the client.  DANE clients MUST send the SNI extension
      with a HostName value of the base domain of the TLSA RRset.
    </t>

    <t>
      Except with TLSA Certificate Usage DANE-EE(3), where name
      checks are not applicable (see <xref target="type3" />), DANE
      clients MUST verify that the client has reached the correct
      server by checking that the server name is listed in the
      server certificate.  The server name used for this comparison
      SHOULD be the base domain of the TLSA RRset.  Additional
      acceptable names may be specified by protocol specific DANE
      standards.  For example, with SMTP both the destination domain
      name and the MX host name are acceptable names to be found
      in the server certificate (see <xref
      target="I-D.ietf-dane-smtp-with-dane"/>).
    </t>

    <t>
      It is the responsibility of the service operator in coordination
      with the TLSA Publisher to ensure that at least one of the
      TLSA records published for the service will match the server's
      certificate chain (either the default chain or selected based
      on the SNI information from the client).  With certificate
      usage values other than DANE-EE(3) the server leaf (EE)
      certificate MUST include the TLSA base domain as one of its
      names, or else if other acceptable names are specified by a
      protocol-specific DANE standard, one of those in place the
      TLSA base domain.
    </t>

    <t>
      Given the DNSSEC validated DNS records below:
    </t>

<figure>
<artwork>
  example.com. IN MX 0 mail.example.com.
  _25._tcp.mail.example.com. IN TLSA 2 0 1 (
                                E8B54E0B4BAA815B06D3462D65FBC7C0
                                CF556ECCF9F5303EBFBB77D022F834C0 )
</artwork>
</figure>

    <t>
      the TLSA base domain is "mail.example.com" and this MUST be the
      HostName in the client's SNI extension.  The server certificate
      chain MUST be signed by a trust-anchor with the above certificate
      SHA2-256 digest.  One of the DNS names in the server certificate
      MUST be either "mail.example.com" or "example.com".
    </t>

  </section>

  <section title="Service Provider and TLSA Publisher Synchronization"
	   anchor="sync">

    <t>
      Complications arise when the TLSA Publisher is not the same
      entity as the Service Provider.  In this situation, the TLSA
      Publisher and the Service Provider must cooperate to ensure that
      TLSA records published by the TLSA Publisher don't fall out of
      sync with the server certificate configuration used by the
      Service Provider.
    </t>

    <t>
      Whenever possible, the TLSA Publisher and the Service Provider
      should be the same entity.  When a TLSA record must be published
      in the Customer Domain's DNS zone, CNAME records may be
      employed to point at the real TLSA record in the Service
      Provider's zone assuming TLSA Certificate Usage DANE-EE(3)
      TLSA records are published by the Service Provider (see <xref
      target="cname"/>).  This also works with TLSA Certificate
      Usage DANE-TA(2), if the service provider internally issues
      a certificate bearing the customer's domain name signed by
      the service provider's trust-anchor domain-issued certificate
      authority.  Having the master TLSA record in the Service
      Provider's zone avoids the complexity of bilateral coordination
      of server certificate configuration and TLSA record management.
    </t>

    <t>
      For example, with SMTP, the Customer Domain's MX hostnames
      can point directly at the Service Provider's SMTP hosts.  When
      the Customer Domain's DNS zone is signed, the MX hostnames
      can be securely used as the base names for TLSA records that
      are published and managed by the Service Provider.
    </t>

    <t>
      If redirection to the Service Provider's domain (via MX or
      SRV records or any similar mechanism) is not possible, and
      aliasing of the TLSA record is not an option, then care must
      be taken during a Service Provider's certificate rollover.
      Before a Service Provider deploys a new certificate chain,
      it must make the matching TLSA records available to all of
      its Customer Domains.  The Customer Domains need to publish
      an additional TLSA record matching the pending certificate
      chain (in addition to TLSA records matching the currently
      deployed certificate chain) in advance of the certificate
      deployment date.  Once the old certificate chain is no longer
      in use, its associated TLSA records that are no longer
      applicable may be removed.
    </t>

  </section>
  <section title="TLSA Base Domain and CNAMEs" anchor="cname">
    <!-- XXXWJH: this section needs a lot of work -->
    <t>
      When the protocol does not support service location indirection
      via MX, SRV or similar DNS records, the service may be
      redirected via a CNAME.  A CNAME is a more blunt instrument for
      this purpose, since unlike an MX or SRV record, it remaps the
      origin domain to the target domain for all protocols, not just a
      singular one.  Also Unlike MX or SRV records, CNAME records may
      chain (though DNS resolving implementations will generally
      impose an implementation dependent maximum nesting depth).
    </t>

    <t>
      When CNAMEs are employed, the best place to seek DANE TLSA records
      is in the Service Provider's domain, as discussed in <xref
      target="sync" />.  Therefore, DANE PKI clients
      connecting to a server whose domain name is a CNAME alias SHOULD
      follow the CNAME hop-by-hop to its ultimate target host
      (noting at each step whether the CNAME is DNSSEC validated) and use
      the final target host as the base domain for TLSA lookups.
    </t>

    <t>
      Implementations failing to find a TLSA record using a base name
      of the final target of a CNAME expansion MAY choose to issue a
      TLSA query using the original destination name.  I.e, the
      preferred tlsa base name would derived for the most-expanded
      name, and failing that would be the initial query name.
    </t>

    <t>
      Protocol-specific TLSA specifications may provide additional
      guidance or restrictions when following CNAME expansions.
    </t>

    <section title="Redirecting TLSA lookups in the Customer Domain">

    <t>
      If CNAMEs are not followed, Customer Domains will need to
      publish TLSA records that match the Service Provider's
      certificate chain or always use an entity that was both the
      Service Provider and the TLSA publisher.  Having the TLSA base
      domain be different than the Service Provider's domain imposes a
      difficult key management burden on the Customer Domain and the
      Service Provider.
    </t>

    <t>
      Fortunately, it is possible to publish CNAMEs in the Customer
      Domain pointing to the Service Provider's TLSA RRset if the TLSA
      certificate usage field is set to DANE-EE(3).  Otherwise, a
      TLS client that used the alias name (from the hosted domain rather
      than the Service Provider's domain) as the base domain to obtain
      the TLSA RRset would look for the hosted domain in the server
      certificate when performing name checks, and would generally
      fail to authenticate the server except in the rare cases when
      the server's certificate does include the Customer Domain.  SNI
      SHOULD be used to help perform the right certificate selection
      by the server, although this imposes a management burden on the
      TLS server that could be avoided by ensuring the TLSA base
      domain is within the Service Provider's control in the first
      place.
    </t>

    <t>Example CNAME record for a TLSA domain:</t>
    <figure>
<artwork>
  ; TLSA RRs aliased to Service Provider, but the base domain is
  ; the hosted domain.  Likely to fail name check unless Service
  ; Provider usage is "3".
  ;
  _25._tcp.mail.example.com. IN CNAME _25._tcp.mail.example.net.
  _25._tcp.mail.example.net. IN TLSA 3 1 1 ...
</artwork>
    </figure>

    <t>
      Note: when the TLSA RRset query domain (base domain plus port and protocol
      prefixes) resolves to a DNSSEC validated CNAME that points to a DNSSEC
      signed zone with the actual TLSA records, as the above example
      indicates, it has no effect on
      the value of the base domain, which remains the original domain to
      which the client prefixed the port and protocol.  In the example
      above, the base domain is "mail.example.com" and not "mail.example.net".
    </t>

    <t>
      Though CNAMEs are illegal on the right hand side of most
      indirection records, such as MX and SRV records, they are
      supported by some implementations.  For example, if the MX or
      SRV host is a CNAME alias, some implementations may "chase" the
      CNAME.  They SHOULD use the target hostname as the base domain for
      TLSA records as well as the HostName in SNI, provided the CNAME
      RR is found to be "secure" at each step in the CNAME expansion.
    </t>
  </section> <!-- Redirecting TLSA lookups in the Customer Domain -->
  </section>
  <section title="TLSA Base Name Priorities">
    <t>There are multiple steps within a chaining DNS lookup process
    that TLSA base names can be pulled from.  This section will
    discuss what the preferred selection points are. TBD.
    <list style="numbers">
      <t>Final Domain Name</t>
      <t>Redirect Name</t>
      <t>Initial Name</t>
    </list>
    </t>
  </section>
  <section title="Interaction with Certificate Transparency">
    <t>
      <xref target="RFC6962"/> Certificate Transparency or CT for short,
      defines an approach to mitigate the risk of rogue or compromised
      public CAs issuing unauthorized certificates.  This section
      clarifies the interaction of CT and DANE.  CT is a protocol and
      auditing system that applies
      only to public CAs, and only when they are free to issue unauthorized
      certificates for a domain.  If the CA is not a public CA, or DANE
      TLSA RRs constrain the end-entity certificate to a fixed public
      key, there is no role for CT, and clients need not apply CT checks.
    </t>

    <t>
      When a server is authenticated via a DANE TLSA RR with TLSA
      Certificate Usage PKIX-EE(1) or DANE-EE(3), the domain owner has
      unambiguously specified the certificate associated with the
      given service.  Even if a rogue CA were able to issue an
      unauthorized end-entity certificate that binds a public key to a
      name in that domain, barring "second preimage" attacks on the
      hashing algorithms in use, any such certificate would not match
      the TLSA record and would be rejected.  Therefore, when a TLS
      client authenticates the TLS server via a TLSA certificate
      association with usage PKIX-EE(1) or DANE-EE(3), CT checks need
      not be performed.  Publication of the server certificate or
      public key (digest) in a TLSA record in a DNSSEC signed zone by
      the domain owner assures the TLS client that the certificate is not
      an unauthorized certificate issued by a rogue CA without the
      domain owner's consent.
    </t>

    <t>
      When a server is authenticated via a DANE TLSA RR with TLSA
      usage DANE-CA(2) and the server certificate does not chain to a
      known public root CA, CT cannot apply (CT logs only accept
      chains that start with a known, public root).  Since TLSA
      Certificate Usage DANE-CA(2) is generally intended to support
      non-PKIX trust anchors, TLS clients need not perform CT checks with
      usage DANE-CA(2) using unknown root CAs.
    </t>
    <t>
      A server operator that wants to perform CT checks should use
      TLSA RRs with usage PKIX-CA(0) and use a known, trusted public
      PKIX root issuer.
    </t>
  </section>
  <section title="Design Considerations for Protocols Using DANE">

    <t>
    When a TLS client goes to the trouble of authenticating a certificate
    presented by a TLS server, it should not continue to use the server in
    case of authentication failure or else authentication serves no
    purpose.
    <!-- XXXWJH: this is not the same as the above and makes no sense:
    Consequently, if a client cannot reliably authenticate
    correctly configured, legitimate servers via a particular combination
    of TLSA parameters, then the client should treat that combination of
    parameters as unusable.  Otherwise, the client risks routinely
    dropping connections to legitimate servers.

    Added sentences to the bottom of the "if all" next paragraph in
    attempt to explain this. 
    -->
    Servers publishing TLSA
    records MUST be configured to allow correctly configured clients to
    successfully authenticate the server's TLS certificate.
    </t>

    <t>
    If all the TLSA records for a service are found unusable (possibly
    due to unsupported parameter combinations), it is application
    protocol specific as to whether the connection should be
    established anyway without relying on TLS security, with only TLS
    encryption but not authentication, or whether to refuse to connect
    entirely.  Protocols must choose whether to prioritize security or
    robustness.  Refusing to connect in the case of unusable
    parameters is clearly the better option if transport security is
    critical, but some protocols may value operational robustness when
    transport security is merely a "nice to have" rather than a requirement.
    </t>

    <section title="Design Considerations for non-PKIX Protocols" anchor="nopki">
      <t>
	For some application protocols, the existing public CA PKI may
	not be viable (such as with SMTP over TLS).  For these (non-PKIX)
	protocols, protocol documents SHOULD NOT suggest publishing
	TLSA records with TLSA Certificate Usage PKIX-CA(0) or
	PKIX-EE(1), as TLS clients cannot be expected to perform <xref
	target="RFC5280"/> PKIX validation or <xref target="RFC6125"/>
	identity verification.
      </t>

      <t>
	Protocols designed for non-PKIX use SHOULD choose to treat any
	TLSA records with TLSA Certificate Usage PKIX-CA(0) or
	PKIX-EE(1) as unusable.  After verifying that the only
	available TLSA Certificate Usage types are PKIX-CA(0) or
	PKIX-EE(1), protocol specifications MAY instruct clients to
	either refuse to initiate a connection or to connect via
	unauthenticated TLS if no alternative authentication
	mechanisms are available.
      </t>

      <t>
	If non-PKIX protocols do allow for publication of TLSA records
	with TLSA Certificate Usage PKIX-CA(0) or PKIX-EE(1), clients
	SHOULD make use of the TLSA verification to the fullest extent
	possible.
      </t>

      <section title="TLSA Certificate Usage PKIX-EE(1)">

	<t>
	  With non-PKIX protocols, clients using TLSA Certificate
	  Usage PKIX-EE(1) records MAY ignore the PKIX validation
	  requirement, and authenticate the server per the content of
	  the TLSA record alone.  Since servers will hopefully rely on
	  SNI to select the correct certificate for presentation, the
	  client SHOULD use the SNI extension to signal the base
	  domain of the TLSA RRset.
	</t>

      </section><!-- TLSA Certificate Usage 1 -->

      <section title="TLSA Certificate Usage PKIX-CA(0)">

	<t>
	  With TLSA Certificate Usage PKIX-CA(0) in non-PKIX
	  protocols, the usability of the TLSA records depends on its
	  matching type.
	</t>

	<t>
	  If the matching type is Full(0), the client has all the
	  information it needs to match the server trust-chain to the
	  TLSA record.  The client MAY ignore the PKIX validation
	  requirement and authenticate the server via its DANE TLSA
	  records alone (sending SNI with the base domain as usual).
	  The client SHOULD use the base domain of the TLSA record(s)
	  in certificate name checks.
	</t>

	<t>
	  If the matching type is not Full(0), the TLSA record
	  contains only a digest of the trust certificate authority
	  certificate or public key.  The full certificate may not be
	  included in the server's certificate chain and the client
	  may not be able to match the server trust chain against the
	  TLSA record when a non-PKIX protocol is being used, as the
	  client won't have the needed CA trust list.  See <xref
	  target="d0"/> for a more complete discussion of this case.
	  The client cannot reliably authenticate the server in this
	  case and SHOULD treat the TLSA record as unusable.
	</t>

	<t>
	  If the client is configured with a set of trusted CAs that
	  are believed to be sufficiently complete to authenticate all
	  the servers it expects to communicate with, then it MAY
	  elect to honor certificate usage PKIX-CA(0) TLSA records that
	  publish digests of the trusted CA certificate or public key.
	</t>

      </section><!-- TLSA Certificate Usage 0 -->
    </section><!-- Design Considerations for non-PKIX Protocols -->
  </section><!-- Design Considerations for Protocols Using DANE -->
  <section title="TLSA Records and Trust Anchor Digests">
    <!-- XXXWJH: this is somewhat duplicate information -->
    <t>
      With TLSA records that match the EE certificate, the TLS client has
      no difficulty matching the TLS record against the server certificate,
      as this certificate is always present in the TLS server certificate
      chain.  The TLS client can, if necessary, extract the public key from
      the server certificate, and can compute the appropriate digest.
    </t>

    <t>
      With DANE TLSA records that match the digest of a TA certificate or
      public key, a complication arises when the TA certificate is omitted
      from the server's certificate chain.  This can happen when the
      trust-anchor is a root certificate authority, as stated in section
      7.4.2 of <xref target="RFC5246"/>:
    </t>

    <figure>
<artwork>
  The sender's certificate MUST come first in the list.  Each
  following certificate MUST directly certify the one preceding
  it.  Because certificate validation requires that root keys be
  distributed independently, the self-signed certificate that
  specifies the root certificate authority MAY be omitted from the
  chain, under the assumption that the remote end must already
  possess it in order to validate it in any case.
</artwork>
      </figure>

    <t>
      This means that TLSA records that match a TA certificate or public
      key digest are not entirely sufficient to validate the peer certificate
      chain.  If no matching certificate is found in the server's certificate
      chain, the chain may be signed by an omitted root CA whose digest
      matches the TLSA record.  We will consider each trust-anchor
      TLSA Certificate Usage in turn.
    </t>

    <section anchor="d0" title="Trust Anchor Digests With TLSA Certificate Usage 0">
      <!-- XXXWJH: need drop much of this, IMHO. We don't need to talk
      about *valid* usage 0 when PKIX is expected to be deployed.
      We're not in the previous section where we were talking about
      protocols that can't use 0/1 -->
      <t>
	In this case, from the server's perspective, the omission of the root
	CA seems reasonable, since in addition to authentication via DANE
	TLSA records, the client is expected to perform <xref target="RFC5280"/>
	PKIX validation of the server's trust chain and thus to already
	have a copy of the omitted root certificate.
      </t>

      <t>
	From the client's perspective the situation is more nuanced.  Despite
	the server's indicated preference for PKIX validation, the client
	may not possess (or may not fully trust) a complete set of public
	root CAs.  This is especially likely in protocols where the existing
	public CA PKI is not applicable, as described in <xref target="nopki"/>.
	If it is likely that a client
	lacks a sufficiently complete list of trusted CAs, and that a
	non-negligible number of DNS servers publish TLSA Certificate Usage PKIX-CA(0) TLSA
	records with digests of omitted root CAs, then such a client SHOULD
	treat such TLSA records as "unusable".  Simply ignoring PKIX
	validation is not an option, since the client will also be unable
	to match the TLSA record without position of the root
	certificate.  The client MAY choose fall back
	to unauthenticated TLS, if PKIX is also not an option
	(see <xref target="I-D.ietf-dane-srv"/>) or refuse to initiate
	a connection.
      </t>

    </section><!-- Trust anchor digests with TLSA Certificate Usage 0 -->

    <section title="Trust Anchor Digests With TLSA Certificate Usage 2">

      <t>
	With TLSA Certificate Usage DANE-CA(2), there is no expectation that the client is pre-configured with
	the trust anchor certificate.  With TLSA Certificate Usage DANE-CA(2)
	clients are expecting to rely
	on the TLSA records alone.  But, with a matching type other than PKIX-CA(0)
	the TLSA records contain neither the full trust anchor certificate
	nor the full public key.  If the TLS server's certificate chain does
	not contain the trust-anchor certificate, clients will be
	unable to authenticate the server.
      </t>

      <t>
	TLSA Publishers that publish TLSA Certificate Usage DANE-CA(2)
	with a non-zero matching type MUST ensure that the corresponding
	server is configured to include the associated trust anchor certificate
	in its TLS handshake certificate chain, even if that certificate is
	a self-signed root CA and would have been optional in the context
	of the existing public CA PKI.
      </t>

      <t>
	Since servers are expected to always provide usage DANE-CA(2) trust
	anchor certificates (either via DNS or else via the TLS hanshake),
	clients SHOULD fully support this TLSA Certificate Usage.  Clients MAY
	choose to treat it as unusable if experience proves that servers
	don't consistently live up to their obligations.
      </t>

    </section><!-- Trust anchor digests with TLSA Certificate Usage 2 -->

  </section><!-- Trust anchor digests -->

  <section title="Trust anchor public keys">

    <t>
      TLSA records with TLSA Certificate Usage PKIX-CA(0) or
      DANE-CA(2), selector SPKI(1) and a matching type of Full(0)
      publish the full public key of a trust anchor via DNS.  In
      section 6.1.1 of <xref target="RFC5280"/> the definition of a
      trust anchor consists of the following four parts:
    </t>

    <t><list style="numbers">
      <t>the trusted issuer name,</t>
      <t>the trusted public key algorithm,</t>
      <t>the trusted public key, and</t>
      <t>optionally, the trusted public key parameters associated with the public key.</t>
    </list></t>

    <t>
      Items 2&ndash;4 are precisely the contents of the subjectPublicKeyInfo
      published in the TLSA record, but the issuer name is not included
      in the public key.
    </t>

    <t>
      With TLSA Certificate Usage PKIX-CA(0), when the client is able to perform PKIX
      validation, the client can construct a complete PKIX trust chain
      as it will have access to the trust anchor name.  So in that case, the
      client can verify that the server certificate chain is issued by a
      trust anchor that matches the TLSA record.
    </t>

    <t>
      With TLSA Certificate Usage DANE-CA(2), the client may not have the missing trust anchor
      certificate, and cannot generally verify whether a particular
      certificate chain is "issued by" the trust anchor described in the
      TLSA record.  If the server certificate chain includes a CA certificate
      whose public key matches the TLSA record, the client can match that
      CA as the intended issuer.  Otherwise, the client can only check
      that the topmost certificate in the server's chain is "signed by"
      by the trust anchor public key in the TLSA record.
    </t>

    <t>
      Since trust chain validation via bare public keys rather than trusted
      CA certificates may be difficult to implement using existing TLS
      libraries, servers SHOULD include the trust anchor certificate in
      their certificate chain when the TLSA Certificate Usage is DANE-CA(2).
    </t>

    <t>
      If none of the server's certificate chain elements match a
      public key specified in full (selector = Cert(0), match type =
      Full(0)) in a TLSA record, clients SHOULD attempt to check
      whether the topmost certificate in the chain is signed by the
      provided public key, and if so consider the server trust chain
      valid, with authentication complete if name checks are also
      successful.
    </t>

  </section><!-- Trust anchor public keys -->

</section>

<section title="Type Specific DANE Guidelines">
  <section title="Type 3 Guidelines" anchor="type3">
  </section>
  <section title="Type 2 Guidelines" anchor="type2">
  </section>
  <section title="Type 1 Guidelines" anchor="type1">
  </section>
  <section title="Type 0 Guidelines" anchor="type0">
    <t>
      TLSA Certificate Usage PKIX-CA(0) allows a domain to publish constraints
      on the set of certificate authorities trusted to issue certificates
      for its TLS servers.  It is expected that clients will only accept
      trust chains which contain a match for one of the published TLSA
      records.  This is simple for TLSA Certificate Usage PKIX-EE(1) where the
      PKIX trust chain always contains the leaf server certificate.
      The situation for TLSA Certificate Usage PKIX-CA(0) is more subtle.
    </t>

    <t>
      TLSA Publishers may publish TLSA records for a
      particular public root CA, expecting that clients will then only
      accept chains anchored at that root.  It is possible, however, that
      the client's set of trusted certificates includes some intermediate
      CAs, either with or without the corresponding root CA.  When a
      client constructs a trust chain leading from a trusted intermediate
      CA to the server leaf certificate, such a chain may omit any trusted
      roots published in the server's TLSA records.
    </t>

    <t>
      If the omitted root is also trusted, the client may erroneously reject
      the server chain if it fails to determine that the shorter chain it
      constructed extends to a longer trusted chain that matches the TLSA
      records.  This means that a client SHOULD not always stop extending
      the chain when the first locally trusted certificate is found.  If
      no TLSA records have matched any of the elements of the chain, it
      MUST attempt to build a longer chain if the trusted certificate
      found is not self-issued, in the hope that a certificate closer to
      the root may in fact match the server's TLSA records.
    </t>
  </section>
</section>

<!-- ************************************************************** -->

<section title="Note on DNSSEC security">

<t>
Clearly the security of the DANE TLSA PKI rests on the security of
the underlying DNSSEC infrastructure.  While this memo is not a guide
to DNSSEC security, a few comments may be helpful to TLSA implementors.
</t>

<t>
With the existing public CA PKI, name constraints are rarely used and
public root CAs can issue certificates for any domain of its choice.
With DNSSEC, the situation is different. Only the registrar of record
can update a domain's DS record in the registry parent zone (in some
cases, however, the registry is the sole registrar).  With gTLDs, for
which multiple registrars compete to provide domains in a single registry,
it is important to make sure that rogue registrars cannot easily initiate
an unauthorized domain transfer, and thus take over DNSSEC for the domain.
DNS Operators SHOULD use a registrar lock of their domains to offer some
protection of this possibility.
</t>

<t>
When the registrar is also the DNS operator for the domain, one needs
to consider whether the registrar will allow orderly migration of the
domain to another registrar or DNS operator in a way that will
maintain DNSSEC integrity.  TLSA Publishers SHOULD ensure their
registrar publishes a suitable domain transfer policy.
</t>

<t>
DNSSEC signed RRsets cannot be securely revoked before they expire.
Operators should plan accordingly and not generate signatures with excessively
long duration.  For domains publishing high-value keys, a signature
lifetime of a few days is reasonable, and the zone should be resigned every
day.  For more domains with less critical data, a reasonable signature lifetime is
a couple of weeks to a month, and the zone should be resigned every
week. Monitoring of the signature lifetime is important.  If the
zone is not resigned in a timely manner, one risks a major outage
with the entire domain becoming invalid.
</t>

</section>

<section anchor="Acknowledgements" title="Acknowledgements">

<t>The authors would like to thank Phil Pennock for his comments and
advice on this document.</t>

<t>
Acknowledgments from Viktor: Thanks to Tony Finch who finally prodded
me into participating in DANE working group discussions.  Thanks to
Paul Hoffman who motivated me to produce this memo and provided
feedback on early drafts.
</t>

</section><!-- Acknowledgements -->

<section anchor="Security" title="Security Considerations">

<t>
Application protocols that cannot make use of the existing public
CA PKI (so called non-PKIX protocols), may choose to not implement
certain PKIX-dependent TLSA record types defined in <xref
target="RFC6698"/>, or may choose to make a best-effort use of such
records.  In neither case is security compromised, since by assumption
PKIX verification is simply not an option for these protocols.  When
the TLS server is authenticated based on the TLSA records alone,
the client is as well authenticated as possible, treating the TLSA
records as unusable would lead to weaker security.
</t>

<t>
Therefore, when TLSA records are used with protocols where PKIX does not
apply, the recommended trade-off is for servers to not publish
PKIX-dependent TLSA records, and for clients to use them as best they can,
but otherwise treat them unusable.  Of course when PKIX validation is an
option clients SHOULD perform PKIX validation per <xref target="RFC6698"/>.
</t>

</section><!-- Security Considerations -->

</middle>

<back>
<references title="Normative References">
&RFC2119;
&RFC4033;
&RFC4034;
&RFC4035;
&RFC4346;
&RFC5246;
&RFC5280;
&RFC6066;
&RFC6125;
&RFC6347;
&RFC6698;
&RFC6962;
</references>
<references title="Informative References">
&I-D.ietf-dane-registry-acronyms;
&I-D.ietf-dane-smtp-with-dane;
&I-D.ietf-dane-srv;
</references>
</back>
</rfc>
