<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4033 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4033.xml">
<!ENTITY RFC4034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY RFC4035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC6066 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY RFC6125 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6698 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6698.xml">
<!ENTITY RFC6962 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6962.xml">
<!ENTITY I-D.ietf-dane-srv SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-srv.xml">
<!ENTITY I-D.ietf-dane-smtp-with-dane SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-smtp-with-dane.xml">
<!ENTITY I-D.ietf-dane-registry-acronyms SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-registry-acronyms.xml">
]>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-dane-ops-@@VERSION@@" ipr="trust200902">

<front>
<title abbrev="DANE operations">Updates to and Operational Guidance for the DANE Protocol</title>
<author fullname="Viktor Dukhovni" initials="V." surname="Dukhovni">
<organization>Unaffiliated</organization>
<address>
<email>ietf-dane@dukhovni.org</email>
</address>
</author>
    <author initials="W.H." surname="Hardaker" fullname="Wes Hardaker">
      <organization>Parsons</organization>
      <address>
        <postal>
          <street>P.O. Box 382</street>
          <city>Davis</city>
          <region>CA</region>
          <code>95617</code>
          <country>US</country>
        </postal>
        <email>ietf@hardakers.net</email>
      </address>
    </author>
<date month="February" year="2014" />
<area>sec</area>
<workgroup>DANE</workgroup>
<keyword>DANE</keyword>
<keyword>TLSA</keyword>

<abstract>

<t>
This memo clarifies and updates the DANE TLSA protocol based on
implementation experience since the publication of the original
specification <xref target="RFC6698"/>.  It also contains
guidance for DANE implementers and operators.
</t>

</abstract>

</front>

<middle>
<section title="Introduction">

<t>
<xref target="RFC6698"/> specifies a new "TLSA" DNS resource
record which associates with a TLS transport endpoint corresponding
trusted leaf or issuing authority certificates or public keys.
DNSSEC-validated DANE TLSA records can be used to augment or replace the
trust model of the existing public Certificate Authority (CA) Public
Key Infrastructure (PKI).
</t>

<t>
<xref target="RFC6698"/> defines three TLSA record parameters that
yield 24 distinct combinations of TLSA record types.  So many options
can lead to implementation and operational complexity.  This memo will
recommend best-practice choices to simplify implementation and deployment.
</t>

<t>
Implementation complexity also arises from the fact that the TLS transport
endpoint is often specified indirectly via Service Records (SRV), Mail
Exchange (MX) records, CNAME records or other mechanisms that map an
abstract service domain to a concrete server domain.  With service
indirection there are multiple potential places for clients to find
the relevant TLSA records.  Service indirection is often used to
implement "virtual hosting", where a single Service Provider transport
endpoint simultaneously supports multiple hosted domain names.  With
services that employ TLS, such hosting arrangements may require the
Service Provider to deploy multiple pairs of private keys and
certificates with TLS clients signalling the desired domain via the
Server Name Indication (SNI) extension (<xref target="RFC6066" />,
section 3).  This memo provides operational guidelines intended to
maximize interoperability between DANE TLS clients and servers.
</t>

<t>
In the context of this memo, channel security is assumed to be
provided by TLS or DTLS.  The Transport Layer Security (TLS) <xref
target="RFC5246" /> and Datagram Transport Layer Security (DTLS) <xref
target="RFC6347" /> protocols provide secured TCP and UDP
communication over IP.  By convention, "TLS" will be used
throughout this document and, unless otherwise specified, the text
applies equally well to the DTLS protocol.  Used without
authentication, TLS provides protection only against eavesdropping
through its use of encryption.  With authentication, TLS also provides
integrity protection and authentication, which protect the transport
against man-in-the-middle (MITM) attacks.
</t>

<section title="Terminology">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",  "MAY",
and "OPTIONAL" in this document are to be interpreted as described
in <xref target="RFC2119"/>.
</t>

<t>The following terms are used throughout this document:
<list style="hanging">
  <t hangText="Service Provider:">
    A company or organization that offers to host a service on behalf
    of a Customer Domain.  The original domain name associated with the
    service often remains under the control of the customer.  Connecting
    applications may be directed to the Service Provider via a redirection
    resource record.  Example redirection records include MX, SRV, and
    CNAME.  The Service Provider frequently provides services for
    many customers and must carefully manage any TLS credentials
    offered to connecting applications to ensure name matching is
    handled easily by the applications.
  </t>
  <t hangText="Customer Domain:">
    Customers that make use of a Service Provider to outsource their
    service(s).
  </t>
  <t hangText="TLSA Publisher:">
    The entity responsible for publishing a TLSA record within a DNS
    zone.  This zone will be considered DNSSEC-signed and validatable
    to a trust anchor, unless otherwise specified.  If the Customer
    Domain is not outsourcing their DNS service, the TLSA Publisher
    will be the customer themselves.  Otherwise the TLSA Publisher may
    be the operator of the outsourced DNS service.
  </t>
  <t hangText="public key:">
    The term "public key" is short-hand for the
    subjectPublicKeyInfo component of a PKIX <xref target="RFC5280" />
    certificate.
  </t>
  <t hangText="SNI:">
    The "Server Name Indication" (SNI) TLS protocol extension allows
    a TLS client to request a connection to a
    particular service name of a TLS server (<xref target="RFC6066"
    />, section 3).  Without this TLS extension, a TLS server has no choice
    but to offer a PKIX certificate with a default list of server
    names, making it difficult to host multiple Customer Domains at
    the same IP-addressed based TLS service endpoint (i.e., "secure virtual hosting").
  </t>
</list>
</t>

</section><!-- Terminology -->

</section><!-- Introduction -->

<section title="DANE TLSA record overview">

  <t>
    DANE TLSA <xref target="RFC6698"/> specifies a protocol for
    publishing TLS server certificate associations via DNSSEC <xref
    target="RFC4033" /> <xref target="RFC4034" /> <xref
    target="RFC4035" />.  The DANE TLSA specification defines multiple
    TLSA RR types via combinations of 3 numeric parameters.  The
    numeric values of these parameters were later given symbolic names
    in <xref target="I-D.ietf-dane-registry-acronyms"/>.  These
    parameters are:
  </t>

  <t>
  <list style='hanging'>

    <t hangText="The TLSA Certificate Usage field:"> Section 2.1.1
    of <xref target="RFC6698"/> specifies 4 values: PKIX-TA(0),
    PKIX-EE(1), DANE-TA(2), and DANE-EE(3).  There is an additional
    private-use value: PrivCert(255).  All other values are reserved
    for use by future specifications.  </t>

    <t hangText="The selector field:"> Section 2.1.2 of <xref
    target="RFC6698"/> specifies 2 values: Cert(0), SPKI(1).  There
    is an additional private-use value: PrivSel(255).  All other
    values are reserved for use by future specifications.  </t>

    <t hangText="The matching type field:"> Section 2.1.3 of <xref
    target="RFC6698"/> specifies 3 values: Full(0), SHA2-256(1),
    SHA2-512(2).  There is an additional private-use value:
    PrivMatch(255).  All other values are reserved for use by future
    specifications.  </t>

  </list>
  </t>

  <t>
    We may think of TLSA Certificate Usage values 0 through 3 as
    a combination of two one-bit flags.  The low-bit chooses between
    trust anchor (TA) and end entity (EE) certificates.  The high bit
    chooses between PKIX, or public PKI issued, and DANE, or
    domain-issued trust anchors:
  </t>

  <t>
  <list style="symbols">

    <t> When the low bit is set (PKIX-EE(1) and DANE-EE(3)) the TLSA
    record matches an EE certificate (also commonly referred to as a
    leaf or server certificate.)</t>

    <t> When the low bit is not set (PKIX-TA(0) and DANE-TA(2)) the
    TLSA record matches a trust anchor (a Certificate Authority)
    that issued one of the certificates in the server certificate
    chain.  </t>

    <t> When the high bit is set (DANE-TA(2) and DANE-EE(3)), the
    server certificate chain is domain-issued and may be verified
    without reference to any pre-existing public certificate authority
    PKI.  Trust is entirely placed on the content of the TLSA records
    obtained via DNSSEC.  </t>

    <t> When the high bit is not set (PKIX-TA(0) and PKIX-EE(1)),
    the TLSA record publishes a server policy stating that its
    certificate chain must pass PKIX validation <xref target="RFC5280"/>
    and the DANE TLSA record is used to signal an additional
    requirement that the PKIX validated server
    certificate chain also contains the referenced CA or EE certificate.
    </t>

  </list>
  </t>

  <t>
    The selector field specifies whether the TLSA RR matches the
    whole certificate (Cert(0)) or just its subjectPublicKeyInfo
    (SPKI(1)).  The subjectPublicKeyInfo is an ASN.1 DER encoding
    of the certificate's algorithm id, any parameters and the public
    key data.
  </t>

  <t>
    The matching type field specifies how the TLSA RR Certificate
    Association Data field is to be compared with the certificate
    or public key.  A value of Full(0) means an exact match: the
    full DER encoding of the certificate or public key is given in
    the TLSA RR.  A value of SHA2-256(1) means that the association
    data matches the SHA2-256 digest of the certificate or public
    key, and likewise SHA2-512(2) means a SHA2-512 digest is used.
    Of the two digest algorithms, for now only SHA2-256(1) is mandatory
    to implement.  Clients SHOULD implement SHA2-512(2), but servers
    SHOULD NOT exclusively publish SHA2-512(2) digests.  A digest algorithm
    agility protocol is proposed in section 2.3.3 of <xref
    target="I-D.ietf-dane-smtp-with-dane"/> that SHOULD be used by
    clients to decide how to process TLSA RRsets that employ multiple
    digest algorithms.  Server operators MUST publish TLSA RRsets
    that are compatible with digest algorithm agility.
  </t>

  <section title="Example TLSA record">
    <t>
      In the example TLSA record below:
    </t>

    <figure>
    <artwork>
  _25._tcp.mail.example.com. 300 IN TLSA PKIX-TA Cert SHA2-256 (
                                 E8B54E0B4BAA815B06D3462D65FBC7C0
                                 CF556ECCF9F5303EBFBB77D022F834C0 )
    </artwork>
    </figure>

    <t>
      The TLSA Certificate Usage is DANE-TA(2), the selector is
      Cert(0) and the matching type is SHA2-256(1).  The last field is
      the Certificate Association Data Field, which in this case
      contains the SHA2-256 digest of the server certificate.
    </t>

  </section><!-- Example TLSA record -->

</section><!-- DANE TLSA record overview -->

<section title="Updates to the DANE Protocol">

<t>Here we list updates to the DANA protocol based on lessons learned
from the implementation and deployment of DANE.</t>

<section title="Specific Certificate Usage  DANE Updates and Guidelines">

  <t>The four Certificate Usage types are discussed below, along with
  notes and updates about how to properly implement and make use of
  them.  They're presented starting from the simplest, usage DANE-EE(3), and working
  backward toward the more complex PKIX-TA(0).</t>

  <section title="Certificate Usage DANE-EE(3) Updates and Guidelines" anchor="type3">

    <t>
      Authentication via certificate usage DANE-EE(3) TLSA records
      involves simply checking that the server's leaf certificate
      matches the TLSA record.  In particular the binding of the server
      public key to its name is based entirely on the TLSA record
      association.  The server MUST be considered authenticated even
      if none of the names in the certificate match the client's
      reference identity for the server.
    </t>

    <t>
      Similarly, with DANE-EE(3), the expiration date of the server
      certificate MUST be ignored, the validity period of the TLSA
      record key binding is determined by the validity interval of
      the TLSA record DNSSEC signature.
    </t>

    <t>
      With DANE-EE(3) servers need not employ SNI (may ignore the
      client's SNI message) even when the server is known under
      multiple domain names that would otherwise require separate
      certificates.  It is instead sufficient for the TLSA RRsets for
      all the domain names in question to match the server's primary
      certificate.  For application protocols where the server name
      is obtained indirectly via SRV, MX or similar records, it is
      simpler still to publish a single hostname as target server
      name for all the hosted domains.
    </t>

    <t>
      In organizations where it is practical to make coordinated
      changes in DNS TLSA records before server key rotation, it is
      generally best to publish end-entity DANE-EE(3) certificate
      associations in preference to other choices of certificate
      usage.  DANE-EE(3) TLSA records support multiple server names
      without SNI, don't suddenly stop working when leaf or intermediate
      certificates expire, and don't fail when the server operator
      neglects to configure all the required issuer certificates in
      the server certificate chain.
    </t>

    <t>
      TLSA records published for DANE servers SHOULD, as a best
      practice, be "DANE-EE(3) SPKI(1) SHA2-256(1)" records.  Since
      all DANE implementations are required to support SHA2-256,
      this record type works for all clients and need not change
      across certificate renewals with the same key.  With no name
      checks required, this TLSA record type supports hosting
      arrangements with a single certificate matching all hosted
      domains!  It is also the easiest to implement correctly in
      the client.
    </t>

  </section>

  <section title="Certificate Usage DANE-TA(2) Guidelines" anchor="type2">

    <t>
      Some domains may prefer to reduce the operational complexity
      of maintaining a distinct TLSA RRset for each TLS service.
      If the domain employs a common issuing certificate authority
      to create certificates for multiple TLS services, it may be
      simpler to publish the issuing authority as a trust anchor
      (TA) for the certificate chains of all relevant services.
      <!-- XXX: should we specify this is true only if the EE cert is
      expected to roll more frequently than the TA key, as otherwise
      it's mostly useless to use type 2 -->
      The TLSA RRs for each service issued by the same TA may then
      be CNAMEs to a common TLSA RRset that matches the TA.  This
      certificate usage also allows Service Providers to independently
      generate appropriate certificates for each Customer Domain
      (see <xref target="sync"/>).
    </t>

    <t>
      As explained in <xref target="tadgst"/>, servers that employ
      Certificate Usage DANE-TA(2) TLSA records MUST include the TA
      certificate as part of the certificate chain presented in the
      TLS handshake even when it is a self-signed root certificate.
      TLSA Publishers should publish either "DANE-TA(2) SPKI(1)
      SHA2-256(1)" or "DANE-TA(2) Cert(0) SHA2-256(1)" TLSA
      parameters.  As with leaf certificate rollover discussed in
      <xref target="type3" />, two such TLSA RRs need to be published
      to facilitate TA certificate rollover.
    </t>

  </section>

  <section title="Certificate Usage PKIX-EE(1) Guidelines" anchor="type1">

    <t>
      From a TLSA record perspective this certificate usage is similar
      to DANE-EE(3), but in addition PKIX verification is required.
      Therefore, name checks, certificate expiration, etc., apply as
      they would without DANE.  It should be noted that an attacker
      who can compromise DNSSEC can replace these with usage
      DANE-EE(3) or DANE-TA(2) TLSA records of his choosing, and thus
      bypass the PKIX verification requirements.
    </t>

    <t>
      Therefore, in most cases this certificate usage offers only
      illusory incremental security over usage DANE-EE(3).  It
      provides lower operational reliability than usage 3 since when
      some clients may not be configured with the required root CA,
      the server's chain may be incomplete or name checks may fail.
      PKIX-EE(1) also requires more complex coordination between the Customer
      Domain and the Service Provider in hosting arrangements.  This
      certificate usage is NOT RECOMMENDED.
    </t>

  </section>

  <section title="Certificate Usage PKIX-TA(0) Guidelines" anchor="type0">

    <t>
      TLSA Certificate Usage PKIX-TA(0) allows a domain to publish
      constraints on the set of certificate authorities trusted to
      issue certificates for its TLS servers.  Clients MUST only
      accept PKIX-verified trust chains which contain a match for
      one of the published TLSA records.
    </t>

    <t>
      TLSA Publishers who publish TLSA records for a particular
      public root CA, will expect that clients will then only accept
      chains anchored at that root.  It is possible, however, that
      the client's trusted certificate store includes some intermediate
      CAs, either with or without the corresponding root CA.  When
      a client constructs a trust chain leading from a trusted
      intermediate CA to the server leaf certificate, such a
      "truncated" chain might not contain a trusted root published
      in the server's TLSA records.
    </t>

    <t>
      If the omitted root is also trusted, the client may erroneously
      reject the server chain if it fails to determine that the
      shorter chain it constructed extends to a longer trusted chain
      that matches the TLSA records.  This means that, when matching a
      usage PKIX-TA(0) TLSA record, a client SHOULD NOT always stop
      extending the chain when the first locally trusted certificate
      is found.  If no TLSA records have matched any of the elements
      of the chain, it MUST attempt to build a longer chain if the
      trusted certificate found is not self-issued, in the hope that a
      certificate closer to the root may in fact match the server's
      TLSA records.
    </t>

    <t>
      As with PKIX-EE(1) case, An attacker who can compromise DNSSEC
      can replace these with usage DANE-EE(3) or DANE-TA(2) TLSA
      records of his choosing and thus bypass the PKIX verification
      requirements.  Therefore, in most cases this certificate usage
      offers only illusory incremental security over usage DANE-TA(2).
      It provides lower reliability than usage DANE-TA(2), since some
      clients may not be configured with the required root CA, and
      additionally requires more complex coordination between the
      Customer Domain and the Service Provider in hosting
      arrangements.  This certificate usage is NOT RECOMMENDED.
    </t>

  </section>

</section>

<section title="Digest algorithm agility" anchor="agility">

<t>
While <xref target="RFC6698"/> specifies multiple digest algorithms,
it does not specify a protocol by which the TLS client and TLSA
record publisher can agree on the strongest shared algorithm.  Such
a protocol would allow the client and server to avoid exposure to
any deprecated weaker algorithms that are published for compatibility
with less capable clients, but should be ignored when possible.  We
specify such a protocol below.
</t>

<t>
<!-- XXXWJH: needs better clarity.  -->
Suppose that a DANE TLS client authenticating a TLS server considers
digest algorithm "BetterAlg" stronger than digest algorithm "WorseAlg".
Suppose further that a server's TLSA RRset contains some records
with "BetterAlg" as the digest algorithm.  Finally, suppose that
for every raw public key or certificate object that is included in
the server's TLSA RRset in digest form, whenever that object appears
with algorithm "WorseAlg" with some usage and selector it also
appears with algorithm "BetterAlg" with the same usage and selector.
In that case our client can safely ignore TLSA records with the
weaker algorithm "WorseAlg", because it suffices to check the records
with the stronger algorithm "BetterAlg".
</t>

<t>
Server operators MUST ensure that for any given usage and selector,
each object (certificate or public key), for which a digest association
exists in the TLSA RRset, is published with the SAME SET of digest
algorithms as all other objects that published with that usage and
selector.  In other words, for each usage and selector, the records
with non-zero matching types will correspond to on a cross-product
of a set of underlying objects and a fixed set of digest algorithms
that apply uniformly to all the objects.
</t>

<t>
To achieve digest algorithm agility, all published TLSA RRsets for use
with DANE TLS MUST conform to the above
requirements.  Then, for each combination of usage and selector, TLS
clients can simply ignore all digest records except those that employ
the strongest digest algorithm.  The ordering of digest algorithms by
strength is not specified in advance, it is entirely up to the TLS
client.  TLS client implementations SHOULD make the
digest algorithm preference order configurable.  Only the future will
tell which algorithms might be weakened by new attacks and when.
</t>

<t>
Note, TLSA records with a matching type of Full(0), that publish the
full value of a certificate or public key object, play no role in
digest algorithm agility.  They neither trump the processing of
records that employ digests, nor are they ignored in the presence
of any records with a digest (i.e. non-zero) matching type.
</t>

<t>
TLS clients SHOULD use digest algorithm agility when processing
the DANE TLSA records of an TLS server.  Algorithm agility is to
be applied after first discarding any unusable or malformed records
(unsupported digest algorithm, or incorrect digest length).  Thus,
for each usage and selector, the client SHOULD process only any
usable records with a matching type of Full(0) and the usable records
whose digest algorithm is believed to be the strongest among usable
records with the given usage and selector.
</t>

<t>
The main impact of this requirement is on key rotation, when the
TLSA RRset is pre-populated with digests of new certificates or
public keys, before these replace or augment their predecessors.
Were the newly introduced RRs to include previously unused digest
algorithms, clients that employ this protocol could potentially
ignore all the digests corresponding to the current keys or
certificates, causing connectivity issues until the new keys or
certificates are deployed.  Similarly, publishing new records with
fewer digests could cause problems for clients using cached TLSA
RRsets that list both the old and new objects once the new keys are
deployed.
</t>

<t>
To avoid problems, server operators SHOULD apply the following strategy:
<list style="symbols">
<t> When changing the set of objects published via the TLSA RRset
(e.g. during key rotation), DO NOT change the set of digest algorithms
used; change just the list of objects. </t>
<t> When changing the set of digest algorithms, change only the set
of algorithms, and generate a new RRset in which all the current objects
are re-published with the new set of digest algorithms. </t>
</list>
</t>

<t>
After either of these two changes are made, the new TLSA RRset
should be left in place long enough that the older TLSA RRset can
be flushed from caches before making another change.
</t>

</section><!-- Digest algorithm agility -->

  <section title="TLS Requirements">

    <t>
      TLS clients that support DANE/TLSA MUST support at least TLS
      1.0 and SHOULD support TLS 1.2.  TLS clients and servers using
      DANE SHOULD support the "Server Name Indication" (SNI) extension
      of TLS.
    </t>

  </section>

  <section title="TLSA Base Domain and CNAMEs" anchor="cname">

    <t>
      When the protocol does not support service location indirection
      via MX, SRV or similar DNS records, the service may be
      redirected via a CNAME.  A CNAME is a more blunt instrument
      for this purpose, since unlike an MX or SRV record, it remaps
      the entire origin domain to the target domain for all protocols.
    </t>

    <t>
      <!-- XXX: DANEbis: Preferred TLSA base domain with CNAME expansion -->
      The complexity of coordinating key rollover is largely
      eliminated when DANE TLSA records are found in the Service
      Provider's domain, as discussed in <xref target="sync" />.
      Therefore, DANE TLS clients connecting to a server whose
      domain name is a CNAME alias SHOULD follow the CNAME hop-by-hop
      to its ultimate target host (noting at each step whether the
      CNAME is DNSSEC-validated).  If at each stage of CNAME expansion
      the DNSSEC validation status is "secure", the final target name
      SHOULD be the preferred base domain for TLSA lookups.
    </t>

    <t>
      <!-- XXX: DANEbis: Fallback TLSA base domain with CNAME expansion -->
      Implementations failing to find a TLSA record using a base
      name of the final target of a CNAME expansion SHOULD issue a
      TLSA query using the original destination name.  That is, the
      preferred TLSA base domain should be derived from the
      fully expanded name, and failing that should be the initial
      domain name.
    </t>

    <t>
      Protocol-specific TLSA specifications may provide additional
      guidance or restrictions when following CNAME expansions.
    </t>

    <t>
      Though CNAMEs are illegal on the right hand side of most
      indirection records, such as MX and SRV records, they are
      supported by some implementations.  For example, if the MX
      or SRV host is a CNAME alias, some implementations may "chase"
      the CNAME.  They SHOULD use the target hostname as the preferred
      TLSA base domain as well as the HostName in SNI, provided the
      CNAME RR is found to be "secure" at each step in the CNAME
      expansion.
    </t>

  </section>

</section>

<section title="General DANE Guidelines">

  <t>
    These guidelines provide guidance for using or designing protocols
    for DANE, regardless of what sort of TLSA record will be used.
  </t>

  <section title="DANE DNS Record Size Guidelines">

    <t>
      Selecting a combination of TLSA parameters to use requires
      careful thought.  One important consideration to take into
      account is the size of the resulting TLSA record after its
      parameters are selected.
    </t>

    <section title="UDP and TCP Considerations">

      <t>
        Deployments SHOULD avoid TLSA record sizes that cause UDP
        fragmentation.
      </t>

      <t>
        Although DNS over TCP would provide the ability to more easily
        transfer larger DNS records between clients and servers, it is
        not universally deployed and is still prohibited by some
        firewalls.  Clients that request DNS records via UDP typically
        only use TCP upon receipt of a truncated response in the DNS
        response message sent over UDP.
      </t>

    </section>

    <!-- XXX: DANEbis: Discourage use of Full(0) -->
    <section title= "Packet Size Considerations for TLSA Parameters">

      <t>
        Server operators SHOULD NOT publish TLSA records using both a
        TLSA Selector of Cert(0) and a TLSA Matching Type of Full(0),
        as even a single certificate is generally too large to be
        reliably delivered via DNS over UDP.  Furthermore, two TLSA
        records containing full certificates will need to be published
        simultaneously during a certificate rollover.
      </t>

      <t>
        While TLSA records using a TLSA Selector of SPKI(1) and a TLSA
        Matching Type of Full(0) (which publish the bare public keys without
	the overhead of a containing X.509 certificate) are generally more
	compact, these too should be used with caution as they are still
	larger than necessary.  Rather, servers SHOULD publish digest-based
	TLSA Matching Types in their TLSA records.
        The complete corresponding certificate should, instead, be
        transmitted to the client in-band during the TLS handshake.
      </t>

      <t>
        In summary, the use of a TLSA Matching Type of Full(0) is NOT
        RECOMMENDED and the use of a digest-based matching type, such
        as SHA2-256(1) SHOULD be used.
      </t>

    </section>

  </section>

  <section title="Certificate Name Check Conventions">

    <t>
      Certificates presented by a TLS server will generally contain a
      subjectAltName (SAN) extension or a Common Name (CN) element in
      the subject distinguished name (DN).  The server's DNS domain name
      is normally published within these elements, ideally within the
      subjectAltName extension. (Use of the CN field for this purpose
      is deprecated.)
      <!--- XXXWJH: Removed this sentence, as it's not within scope of
          the document and restates what is defined in PKIX
          processing:

          Name checks SHOULD NOT consider the subject CN when SAN
          values of type 'dns' are present. -->
    </t>

    <t>
      <!-- XXX: DANEbis: Mandate use of SNI by clients -->
      When a server hosts multiple domains at the same transport
      endpoint, the server's ability to respond with the right
      certificate chain is predicated on correct SNI information
      from the client.  DANE clients MUST send the SNI extension
      with a HostName value of the base domain of the TLSA RRset.
    </t>

    <t>
      <!-- XXX: DANEbis: Specify name check requirements -->
      Except with TLSA Certificate Usage DANE-EE(3), where name
      checks are not applicable (see <xref target="type3" />), DANE
      clients MUST verify that the client has reached the correct
      server by checking that the server name is listed in the
      server certificate's SAN or CN.  The server name used for this comparison
      SHOULD be the base domain of the TLSA RRset.  Additional
      acceptable names may be specified by protocol-specific DANE
      standards.  For example, with SMTP both the destination domain
      name and the MX host name are acceptable names to be found
      in the server certificate (see <xref
      target="I-D.ietf-dane-smtp-with-dane"/>).
    </t>

    <t>
      It is the responsibility of the service operator, in
      coordination with the TLSA Publisher, to ensure that at least
      one of the TLSA records published for the service will match the
      server's certificate chain (either the default chain or the
      certificate that was selected based on the SNI information
      provided by the
      client).
    </t>

    <t>
      Given the DNSSEC validated DNS records below:
    </t>

    <figure>
    <artwork>
  example.com.               300 IN MX 0 mail.example.com.
  _25._tcp.mail.example.com. 300 IN TLSA DANE-TA Cert SHA2-256  (
                                 E8B54E0B4BAA815B06D3462D65FBC7C0
                                 CF556ECCF9F5303EBFBB77D022F834C0 )
    </artwork>
    </figure>

    <t>
      <!-- XXX: should probably state that a mail.example.com is a
           record and not a CNAME? And more importantly that there is
           no TLSA record at _25._tcp.example.com itself, or the MUST
           doesn't apply because either can be used.  Because we
           select multiple base names in the SMTP draft, so the below
           doesn't match perfectly unless _25._tcp.example.com doesn't
           exist. -->
      The TLSA base domain is "mail.example.com" and this is required to be be the
      HostName in the client's SNI extension.  The server certificate
      chain is required to be be signed by a trust anchor with the above certificate
      SHA2-256 digest.  Finally, one of the DNS names in the server certificate
      is required to be be either "mail.example.com" or "example.com".
    </t>

  </section>

  <section title="Service Provider and TLSA Publisher Synchronization"
           anchor="sync">

    <t>
      Complications arise when the TLSA Publisher is not the same
      entity as the Service Provider.  In this situation, the TLSA
      Publisher and the Service Provider must cooperate to ensure that
      TLSA records published by the TLSA Publisher don't fall out of
      sync with the server certificate used by the
      Service Provider.
    </t>

    <t>
      <!-- XXX: DANEbis: Explain how DANE-EE(3) and DANE-TA(2) make it
       it possible to avoid the need for service providers to obtain keys
       from clients, or alternatively for clients to publish TLSA RRs
       for provider generated keys. SNI is needed with DANE-TA(2), but
       the key material and TLSA RRs are managed unilaterally by the
       Service Provider. -->
      Whenever possible, the TLSA Publisher and the Service Provider
      should be the same entity.  Otherwise, changes in the service
      certificate chain must be carefully coordinated between the
      parties involved.  Such coordination is difficult and service
      outages will result when coordination fails.
    </t>

    <t>
      Having the master TLSA record in the Service Provider's zone
      avoids the complexity of bilateral coordination of server
      certificate configuration and TLSA record management.  Even when
      the TLSA RRset must be published in the Customer Domain's DNS
      zone, it is possible to employ CNAME records (see <xref
      target="cname"/>) to delegate the content of the TLSA RRset to a
      domain operated by the Service Provider.  Certificate name
      checks generally constrain the applicability of TLSA CNAMEs
      across organizational boundaries to Certificate Usages
      DANE-EE(3) and DANE-TA(2):
    </t>

    <t>
    <list style="hanging">

    <t hangText="Certificate Usage DANE-EE(3):"> In this case the
    Service Provider can publish a single TLSA RRset that matches the
    server certificate or public key digest.  The same RRset works for
    all Customer Domains because name checks do not apply with
    DANE-EE(3) TLSA records (see <xref target="type3" />).  A
    Customer Domain can create a CNAME record pointing to the TLSA
    RRset published by the Service Provider.  </t>

    <t hangText="Certificate Usage DANE-TA(2):"> When the Service
    Provider operates a private certificate authority, the Service
    Provider is free to issue a certificate bearing any customer's
    domain name.  Without DANE, such a certificate would not pass
    trust verification, but with DANE, the customer's TLSA RRset that
    is aliased to the provider's TLSA RRset can delegate authority to
    the provider's CA for the corresponding service.  The Service
    Provider can generate appropriate certificates for each customer
    and use the SNI information provided by clients to select the right certificate chain to present to
    each client. </t>

    </list>
    </t>

    <t>
      Below are example DNS records (without the required DNSSEC
      information, such as record signatures) that illustrate both of
      of the above cases in the case of an HTTPS service whose clients
      all support DANE TLS.
    </t>

    <figure>
    <artwork>
; Hosted web service redirected via a CNAME alias.
; Associated TLSA RRset redirected via a CNAME alias.
;
; A single certificate at the provider works for all Customer
; Domains due to the use of the DANE-EE certificate usage type.
;
www1.example.com.             300 IN CNAME w1.example.net.
_443._tcp.www1.example.com.   300 IN CNAME _443._tcp.w1.example.net.
_443._tcp.w1.example.net.     300 IN TLSA  DANE-EE SPKI SHA2-256 (
                              8A9A70596E869BED72C69D97A8895DFA
                              D86F300A343FECEFF19E89C27C896BC9 )
;
; A CA at the provider can also issue certificates for each Customer
; Domain, and use the DANE-TA certificate usage type to
; indicate a trust anchor.
;
www2.example.com.             300 IN CNAME w2.example.net.
_443._tcp.www2.example.com.   300 IN CNAME _443._tcp.w2.example.net.
_443._tcp.w2.example.net.     300 IN TLSA DANE-TA Cert SHA2-256 (
                              C164B2C3F36D068D42A6138E446152F5
                              68615F28C69BD96A73E354CAC88ED00C )
    </artwork>
    </figure>

    <t>
      <!-- XXX: DANEbis: Note redirection of TLSA base domain via MX, SRV
      and related records -->
      With protocols that support explicit transport redirection
      via DNS MX records, SRV records, or other similar records,
      the TLSA base domain is based on the redirected transport
      end-point, rather than the origin domain.  With SMTP for
      example, when email service is hosted by a Service Provider,
      the Customer Domain's MX hostnames will point at the Service
      Provider's SMTP hosts.  When the Customer Domain's DNS zone
      is signed, the MX hostnames can be securely used as the base
      domains for TLSA records that are published and managed by the
      Service Provider.  For example (without the required DNSSEC
      information, such as record signatures):
    </t>

    <figure>
    <artwork>
  ; Hosted SMTP service
  ;
  example.com.              300 IN MX 0 mx1.example.net.
  example.com.              300 IN MX 0 mx2.example.net.
  _25._tcp.mx1.example.net. 300 IN TLSA DANE-EE SPKI SHA2-256 (
                                8A9A70596E869BED72C69D97A8895DFA
                                D86F300A343FECEFF19E89C27C896BC9 )
  _25._tcp.mx2.example.net. 300 IN TLSA DANE-EE SPKI SHA2-256 (
                                C164B2C3F36D068D42A6138E446152F5
                                68615F28C69BD96A73E354CAC88ED00C )
    </artwork>
    </figure>

    <t>
      If redirection to the Service Provider's domain (via MX or
      SRV records or any similar mechanism) is not possible, and
      aliasing of the TLSA record is not an option, then more complex
      coordination between the Customer Domain and Service Provider
      is required.  Either the Customer Domain periodically provides
      private keys and a corresponding certificate chain to the
      Provider after making appropriate changes in its TLSA records,
      or the Service Provider periodically generates the keys and
      certificates and must wait for matching TLSA records to be
      published by its Customer Domains before deploying newly
      generated keys and certificate chains.
    </t>

    <t>For further information about combining DANE and SRV, please
    see <xref target="I-D.ietf-dane-srv" />.
    </t>

  </section>

  <section title="Design Considerations for Protocols Using DANE">

    <t>
      When a TLS client goes to the trouble of authenticating a
      certificate chain presented by a TLS server, it should not
      continue to use that server in the event of authentication failure,
      or else authentication serves no purpose.  Servers publishing
      TLSA records MUST be configured to allow correctly configured
      clients to successfully authenticate their TLS certificate
      chains.
    </t>

    <!-- XXX: DANEbis: Opportunistic TLS discovery. -->
    <t>
      A service with DNSSEC-validated TLSA records implicitly
      promises TLS support.  When all the TLSA records for a service
      are found "unusable", due to unsupported parameter combinations
      or malformed associated data, DANE clients cannot authenticate
      the service certificate chain.  When authenticated TLS is
      dictated by the application, the client SHOULD NOT connect
      to the associated server.  If, on the other hand, the use of
      TLS is "opportunistic", then the client SHOULD generally use
      the server via an unauthenticated TLS connection, but if TLS
      encryption cannot be established, the client MUST NOT use the
      server.  Standards for DANE specific to the particular
      application protocol may modify the above as appropriate to
      specify whether the connection should be established anyway
      without relying on TLS security, with only encryption but
      not authentication, or whether to refuse to connect entirely.
      Protocols must choose whether to prioritize security or
      robustness.
    </t>

    <section title="Design Considerations for non-PKIX Protocols" anchor="nopki">

      <!-- XXX: DANEbis: App protocols may define non-usability of CU-[01]. -->
      <t>
        For some application protocols (such as SMTP to MX with
        opportunistic TLS), the existing public CA PKI is not a
        viable alternative to DANE.  For these (non-PKIX) protocols,
        new DANE standards SHOULD NOT suggest publishing TLSA records
        with TLSA Certificate Usage PKIX-TA(0) or PKIX-EE(1), as
        TLS clients cannot be expected to perform <xref target="RFC5280"/>
        PKIX validation or <xref target="RFC6125"/> identity
        verification.
      </t>

      <t>
        Protocols designed for non-PKIX use SHOULD choose to treat any
        TLSA records with TLSA Certificate Usage PKIX-TA(0) or
        PKIX-EE(1) as unusable.  After verifying that the only
        available TLSA Certificate Usage types are PKIX-TA(0) or
        PKIX-EE(1), protocol specifications MAY instruct clients to
        either refuse to initiate a connection or to connect via
        unauthenticated TLS if no alternative authentication
        mechanisms are available.
      </t>

    </section><!-- Design Considerations for non-PKIX Protocols -->

  </section><!-- Design Considerations for Protocols Using DANE -->

  <section title="TLSA Records and Trust Anchor Digests" anchor="tadgst">

    <!-- XXX: DANEbis: Servers must send DANE-TA(2) certs in TLS chain. -->
    <t>
      With TLSA records that match the EE certificate (i.e., DANE-EE(3) or
      PKIX-EE(1)), the TLS client has no difficulty matching TLSA records
      against the server certificate, as this certificate is always
      present in the TLS server certificate chain.
    </t>

    <t>
      With DANE TLSA records that match the digest of a TA certificate
      or public key (i.e., DANE-TA(2) or PKIX-TA(0)), a complication
      arises when the TA certificate is omitted from the server's
      certificate chain.  This can happen when the trust anchor is a
      root certificate authority, as stated in section
      7.4.2 of <xref target="RFC5246"/>:
    </t>

    <figure>
      <artwork>
  The sender's certificate MUST come first in the list.  Each
  following certificate MUST directly certify the one preceding
  it.  Because certificate validation requires that root keys be
  distributed independently, the self-signed certificate that
  specifies the root certificate authority MAY be omitted from the
  chain, under the assumption that the remote end must already
  possess it in order to validate it in any case.
      </artwork>
    </figure>

    <t>
      This means that TLSA records that match a TA certificate or public
      key digest are not entirely sufficient to validate the peer certificate
      chain.  If no matching certificate is found in the server's certificate
      chain, the chain may be signed by an omitted root CA whose digest
      matches the TLSA record.  With Certificate Usage PKIX-TA(0), this is
      not a problem, since the client is expected to be pre-configured with
      the issuing TA certificate.
    </t>

    <t>
      With TLSA Certificate Usage DANE-TA(2), however, there is no expectation
      that the client is pre-configured with the trust anchor
      certificate.  Rather, with TLSA Certificate Usage DANE-TA(2)
      clients must be able to rely on the TLSA records alone.  But,
      with a digest in the TLSA record, the TLSA record contains
      neither the full trust anchor certificate nor the full public
      key.  If the TLS server's certificate chain does not contain
      the trust anchor certificate, DANE clients will be unable to
      authenticate the server.
    </t>

    <t>
      TLSA Publishers that publish TLSA Certificate Usage DANE-TA(2)
      with a digest (not Full(0)) matching type MUST ensure that
      the corresponding server is configured to also include the
      trust anchor certificate in its TLS handshake certificate
      chain, even if that certificate is a self-signed root CA and
      would have been optional in the context of the existing public
      CA PKI.
    </t>

  </section><!-- Trust anchor digests -->

  <section title="Trust anchor public keys">

    <!-- XXX: DANEbis: clarify "IN TLSA 2 1 0" requirements. -->
    <t>
      TLSA records with TLSA Certificate Usage DANE-TA(2), selector
      SPKI(1) and a matching type of Full(0) publish the full public
      key of a trust anchor via DNS.  In section 6.1.1 of <xref
      target="RFC5280"/> the definition of a trust anchor consists
      of the following four parts:
    </t>

    <t><list style="numbers">
      <t>the trusted issuer name,</t>
      <t>the trusted public key algorithm,</t>
      <t>the trusted public key, and</t>
      <t>optionally, the trusted public key parameters associated
         with the public key.</t>
    </list></t>

    <t>
      Items 2&ndash;4 are precisely the contents of the subjectPublicKeyInfo
      published in the TLSA record, but the issuer name is not included
      in the public key.
    </t>

    <t>
      With TLSA Certificate Usage DANE-TA(2), the client may not
      have the associated trust anchor certificate, and cannot generally
      verify whether a particular certificate chain is "issued by"
      the trust anchor described in the TLSA record.  If the server
      certificate chain includes a CA certificate whose public key
      matches the TLSA record, the client can match that CA as the
      intended issuer.  Otherwise, the client can only check that
      the topmost certificate in the server's chain is "signed by"
      the trust anchor public key in the TLSA record.
    </t>

    <t>
      Since trust chain validation via bare public keys rather than trusted
      CA certificates may be difficult to implement using existing TLS
      libraries, servers SHOULD include the trust anchor certificate in
      their certificate chains when the TLSA Certificate Usage is DANE-TA(2).
    </t>

    <t>
      If none of the server's certificate chain elements match a
      public key specified in full in a TLSA record, clients SHOULD
      check whether the topmost certificate in the chain is signed
      by the provided public key and has not expired, and if that
      is the case, and the rest of the chain passes validation,
      consider the server authenticated if name checks are also
      successful.
    </t>

  </section><!-- Trust anchor public keys -->

</section>
  <section title="Interaction with Certificate Transparency">
  <!-- XXX: DANEbis: CT interaction: No CT for DANE-TA/EE -->

    <t>
      Certificate Transparency (CT) <xref target="RFC6962"/> defines
      an experimental approach to mitigate the risk of rogue or
      compromised public CAs issuing unauthorized certificates.  This
      section clarifies the interaction of CT and DANE.  CT is an
      experimental protocol and auditing system that applies only to
      public CAs, and only when they are free to issue unauthorized
      certificates for a domain.  If the CA is not a public CA, or a
      DANE-EE(3) TLSA RR directly specifies the end entity
      certificate, there is no role for CT, and clients need not apply
      CT checks.
    </t>

    <t>
      When a server is authenticated via a DANE TLSA RR with TLSA
      Certificate Usage DANE-EE(3), the domain owner has directly
      specified the certificate associated with the given service
      without reference to any PKIX certificate authority.  Therefore,
      when a TLS client authenticates the TLS server via a TLSA
      certificate association with usage DANE-EE(3), CT checks SHOULD
      NOT be performed.  Publication of the server certificate or
      public key (digest) in a TLSA record in a DNSSEC signed zone
      by the domain owner assures the TLS client that the certificate
      is not an unauthorized certificate issued by a rogue CA without
      the domain owner's consent.
    </t>

    <t>
      When a server is authenticated via a DANE TLSA RR with TLSA
      usage DANE-TA(2) and the server certificate does not chain
      to a known public root CA, CT cannot apply (CT logs only
      accept chains that start with a known, public root).  Since
      TLSA Certificate Usage DANE-TA(2) is generally intended to
      support non-PKIX trust anchors, TLS clients SHOULD NOT perform
      CT checks with usage DANE-TA(2) using unknown root CAs.
    </t>

    <t>
      A server operator who wants clients to perform CT checks
      should publish TLSA RRs with usage PKIX-TA(0) or PKIX-EE(1).
    </t>

  </section>

<section title="Note on DNSSEC security">

  <t>
    Clearly the security of the DANE TLSA PKI rests on the security
    of the underlying DNSSEC infrastructure.  While this memo is
    not a guide to DNSSEC security, a few comments may be helpful
    to TLSA implementors.
  </t>

  <t>
    <!-- XXXWJH for viktor: name constraints are rarely used??  Huh???
    When did that creep in, as it's not at all accurate, but I'm not
    removing it till you can explain it.  -->
    With the existing public CA PKI, name constraints are rarely
    used, and a public root CA can issue certificates for any domain
    of its choice.  With DNSSEC, the situation is different. Only
    the registrar of record can update a domain's DS record in the
    registry parent zone (in some cases, however, the registry is
    the sole registrar).  With many gTLDs, for which multiple registrars
    compete to provide domains in a single registry, it is important
    to make sure that rogue registrars cannot easily initiate an
    unauthorized domain transfer, and thus take over DNSSEC for the
    domain.  DNS Operators SHOULD use a registrar lock of their
    domains to offer some protection against this possibility.
  </t>

  <t>
    When the registrar is also the DNS operator for the domain, one
    needs to consider whether the registrar will allow orderly
    migration of the domain to another registrar or DNS operator
    in a way that will maintain DNSSEC integrity.  TLSA Publishers
    SHOULD ensure their registrar publishes a suitable domain
    transfer policy.
  </t>

  <t>
    DNSSEC signed RRsets cannot be securely revoked before they
    expire.  Operators should plan accordingly and not generate
    signatures with excessively long duration.  For domains publishing
    high-value keys, a signature lifetime of a few days is reasonable,
    and the zone should be resigned daily.  For domains with
    less critical data, a reasonable signature lifetime is a couple
    of weeks to a month, and the zone should be resigned weekly.
    Monitoring of the signature lifetime is important.  If the zone
    is not resigned in a timely manner, one risks a major outage
    with the entire domain becoming invalid.
  </t>

</section>

<section anchor="Security" title="Security Considerations">

  <t>
    Application protocols that cannot make use of the existing public
    CA PKI (so called non-PKIX protocols), may choose not to implement
    certain PKIX-dependent TLSA record types defined in <xref
    target="RFC6698"/>.  If such records are published despite
    not being supported by the application protocol, they are treated as
    "unusable".  When TLS is opportunistic, the client may proceed
    to use the server with mandatory unauthenticated TLS.  This is stronger
    than opportunistic TLS without DANE, since in that case the client
    may also proceed with a plaintext connection.  When TLS is not
    opportunistic, the client MUST NOT connect to the server.
  </t>

  <t>
    Therefore, when TLSA records are used with protocols where PKIX
    does not apply, the recommended policy is for servers to not
    publish PKIX-dependent TLSA records, and for opportunistic TLS
    clients to use them to enforce the use of (albeit unauthenticated)
    TLS, but otherwise treat them as unusable.  Of course, when PKIX
    validation is supported by the application protocol, clients
    SHOULD perform PKIX validation per <xref target="RFC6698"/>.
  </t>

</section><!-- Security Considerations -->

<section title="IANA considerations">
  <t>This specification requires no support from IANA.</t>
</section>

<section anchor="Acknowledgements" title="Acknowledgements">

  <t>
    The authors would like to thank Phil Pennock for his comments and
    advice on this document.
  </t>

  <t>
    Acknowledgments from Viktor: Thanks to Tony Finch who finally
    prodded me into participating in DANE working group discussions.
    Thanks to Paul Hoffman who motivated me to produce this memo
    and provided feedback on early drafts.  Thanks also to Samuel
    Dukhovni for editorial assistance.
  </t>

</section><!-- Acknowledgements -->

</middle>

<back>
<references title="Normative References">
&RFC2119;
&RFC4033;
&RFC4034;
&RFC4035;
&RFC5246;
&RFC5280;
&RFC6066;
&RFC6125;
&RFC6347;
&RFC6698;
</references>
<references title="Informative References">
&RFC6962;
&I-D.ietf-dane-registry-acronyms;
&I-D.ietf-dane-smtp-with-dane;
&I-D.ietf-dane-srv;
</references>
</back>
</rfc>
