<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4033 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4033.xml">
<!ENTITY RFC4034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY RFC4035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC6066 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY RFC6125 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6698 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6698.xml">
<!ENTITY RFC6781 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6781.xml">
<!ENTITY RFC6962 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6962.xml">
<!ENTITY RFC7218 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7218.xml">
<!ENTITY RFC7250 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7250.xml">
<!ENTITY RFC7435 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7435.xml">
<!ENTITY I-D.ietf-dane-srv SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-srv.xml">
<!ENTITY I-D.ietf-dane-smtp-with-dane SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-smtp-with-dane.xml">
]>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-dane-ops-@@VERSION@@" ipr="trust200902">

<front>
<title abbrev="DANE operations">Updates to and Operational Guidance for the DANE Protocol</title>
<author fullname="Viktor Dukhovni" initials="V." surname="Dukhovni">
<organization>Unaffiliated</organization>
<address>
<email>ietf-dane@dukhovni.org</email>
</address>
</author>
    <author initials="W.H." surname="Hardaker" fullname="Wes Hardaker">
      <organization>Parsons</organization>
      <address>
        <postal>
          <street>P.O. Box 382</street>
          <city>Davis</city>
          <region>CA</region>
          <code>95617</code>
          <country>US</country>
        </postal>
        <email>ietf@hardakers.net</email>
      </address>
    </author>
<date/>
<area>sec</area>
<workgroup>DANE</workgroup>
<keyword>DANE</keyword>
<keyword>TLSA</keyword>

<abstract>

<t>
  This document clarifies and updates the DNS-Based Authentication of
  Named Entities (DANE) TLSA specification based on subsequent
  implementation experience.  It also contains guidance for
  implementers, operators and protocol developers who want to make
  use of DANE records.
</t>

</abstract>

</front>

<middle>
<section title="Introduction">
  <t>
    The DANE TLSA specification (<xref target="RFC6698"/>) introduces
    the DNS "TLSA" resource record type.  TLSA records associate a
    certificate or a public key of an end-entity or a trusted issuing
    authority with the corresponding TLS transport endpoint.  DNSSEC
    validated DANE TLSA records can be used to augment or replace
    the use of trusted public Certification Authorities (CAs).
  </t>

  <t>
    <xref target="RFC6698"/> defines three TLSA record fields with
    respectively 4, 2 and 3 currently specified values.  These yield
    24 distinct combinations of TLSA record types.  This document
    recommends a smaller set of best-practice combinations of these
    fields to simplify protocol design, implementation and deployment.
  </t>

  <t>
    Implementation complexity also arises from the fact that the
    TLS transport endpoint is often specified indirectly via Service
    Records (SRV), Mail Exchange (MX) records, CNAME records or
    other mechanisms that map an abstract service domain to a
    concrete server domain.  With service indirection there are
    multiple potential places for clients to find the relevant TLSA
    records.  Service indirection is often used to implement "virtual
    hosting", where a single Service Provider transport endpoint
    simultaneously supports multiple hosted domain names.  With
    services that employ TLS, such hosting arrangements may require
    the Service Provider to deploy multiple pairs of private keys
    and certificates. The TLS clients, then, signal the desired domain
    to the TLSA server via the Server Name Indication (SNI) extension (<xref
    target="RFC6066" />, section 3).  This document provides operational
    guidelines intended to maximize interoperability between DANE
    TLS clients and servers.
  </t>

  <t>
    In the context of this document, channel security is assumed to be
    provided by TLS or DTLS.  The Transport Layer Security (TLS)
    <xref target="RFC5246" /> and Datagram Transport Layer Security
    (DTLS) <xref target="RFC6347" /> protocols provide secured TCP
    and UDP communication, respectively, over IP.  By convention, "TLS" will be
    used throughout this document and, unless otherwise specified,
    the text applies equally well to the DTLS over UDP protocol.  Used without
    authentication, TLS provides protection only against eavesdropping
    through its use of encryption.  With authentication, TLS also
    provides integrity protection and authentication, which protects
    the transport against man-in-the-middle (MITM) attacks.
  </t>

  <t>
    Other related documents that build on <xref target="RFC6698"/> are
    <xref target="I-D.ietf-dane-srv"/> and <xref
    target="I-D.ietf-dane-smtp-with-dane"/>.
  </t>

  <t>
    In <xref target="updates"/>
    we summarize the normative updates this document makes to <xref
    target="RFC6698"/>.
  </t>

  <section title="Terminology">

    <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted
      as described in <xref target="RFC2119"/>.
    </t>

    <t>The following terms are used throughout this document:
    <list style="hanging">
      <t hangText="Service Provider:">
	A company or organization that offers to host a service on behalf
	of the owner of a Customer Domain.  The original domain name associated with the
	service often remains under the control of the customer.  Connecting
	applications may be directed to the Service Provider via a redirection
	resource record.  Example redirection records include MX, SRV, and
	CNAME.  The Service Provider frequently provides services for
	many customers and must carefully manage any TLS credentials
	offered to connecting applications to ensure name matching is
	handled easily by the applications.
      </t>
      <t hangText="Customer Domain:">
	As described above, a TLS client may be interacting with a
	service that is hosted by a third party.  We will refer to
	the domain name used to locate the service (prior to any
	redirection) as the "Customer Domain".
      </t>
      <t hangText="TLSA Publisher:">
	The entity responsible for publishing a TLSA record within a DNS
	zone.  This zone will be assumed DNSSEC-signed and validatable
	to a trust anchor, unless otherwise specified.  If the Customer
	Domain is not outsourcing their DNS service, the TLSA Publisher
	will be the customer themselves.  Otherwise, the TLSA Publisher
	may be the operator of the outsourced DNS service.
      </t>
      <t hangText="public key:">
	The term "public key" is short-hand for the
	subjectPublicKeyInfo component of a PKIX <xref target="RFC5280" />
	certificate.
      </t>
      <t hangText="SNI:">
	The "Server Name Indication" (SNI) TLS protocol extension allows
	a TLS client to request a connection to a
	particular service name of a TLS server (<xref target="RFC6066"
	/>, section 3).  Without this TLS extension, a TLS server has no choice
	but to offer a PKIX certificate with a default list of server
	names, making it difficult to host multiple Customer Domains at
	the same IP-addressed based TLS service endpoint (i.e., "secure virtual hosting").
      </t>
      <t hangText="TLSA parameters:">
	In <xref target="RFC6698"/> the TLSA record is defined to
	consist of four fields.  The first three of these are numeric
	parameters that specify the meaning of the data in fourth and final
	field.  To avoid language contortions when we need to distinguish
	between the first three fields that together define a TLSA record
	"type" and the fourth that provides a data value of that type,
	we will call the first three fields "TLSA parameters", or sometimes
	just "parameters" when obvious from context.
      </t>
    </list>
    </t>

  </section><!-- Terminology -->

</section><!-- Introduction -->

<section title="DANE TLSA Record Overview" anchor="overview">

  <t>
    DANE TLSA <xref target="RFC6698"/> specifies a protocol for
    publishing TLS server certificate associations via DNSSEC <xref
    target="RFC4033" /> <xref target="RFC4034" /> <xref
    target="RFC4035" />.  The DANE TLSA specification defines multiple
    TLSA RR types via combinations of numeric values of the first three
    fields of the TLSA record (i.e. the "TLSA parameters").  The
    numeric values of these parameters were later given symbolic names
    in <xref target="RFC7218"/>.  These parameters are:
  </t>

  <t>
  <list style='hanging'>

    <t hangText="The Certificate Usage field:"> Section 2.1.1 of
    <xref target="RFC6698"/> specifies 4 values: PKIX-TA(0),
    PKIX-EE(1), DANE-TA(2), and DANE-EE(3).  There is an additional
    private-use value: PrivCert(255), which, given its private
    scope, shall not be considered further in this document.  All
    other values are reserved for use by future specifications.
    </t>

    <t hangText="The selector field:"> Section 2.1.2 of <xref
    target="RFC6698"/> specifies 2 values: Cert(0), SPKI(1).  There
    is an additional private-use value: PrivSel(255).  All other
    values are reserved for use by future specifications.  </t>

    <t hangText="The matching type field:"> Section 2.1.3 of <xref
    target="RFC6698"/> specifies 3 values: Full(0), SHA2-256(1),
    SHA2-512(2).  There is an additional private-use value:
    PrivMatch(255).  All other values are reserved for use by future
    specifications.  </t>

  </list>
  </t>

  <t>
    We may think of TLSA Certificate Usage values 0 through 3 as a
    combination of two one-bit flags.  The low-bit chooses between
    trust anchor (TA) and end entity (EE) certificates.  The high
    bit chooses between PKIX (public PKI issued) and DANE (domain-issued)
    trust anchors:
  </t>

  <t>
  <list style="symbols">

    <t> When the low bit is set (PKIX-EE(1) and DANE-EE(3)) the TLSA
    record matches an EE certificate (also commonly referred to as a
    leaf or server certificate.)</t>

    <t> When the low bit is not set (PKIX-TA(0) and DANE-TA(2)) the
    TLSA record matches a trust anchor (a Certification Authority)
    that issued one of the certificates in the server certificate
    chain.  </t>

    <t> When the high bit is set (DANE-TA(2) and DANE-EE(3)), the
    server certificate chain is domain-issued and may be verified
    without reference to any pre-configured Certification Authority
    trust anchor.  Trust is based solely on the content of the
    TLSA records obtained via DNSSEC.  </t>

    <t> When the high bit is not set (PKIX-TA(0) and PKIX-EE(1)),
    the TLSA record publishes a server policy stating that its
    certificate chain must pass PKIX validation <xref target="RFC5280"/>
    and the DANE TLSA record is used to signal an additional
    requirement that the PKIX validated server
    certificate chain also contains the referenced CA or EE certificate.
    </t>

  </list>
  </t>

  <t>
    The selector field specifies whether the TLSA RR matches the
    whole certificate (Cert(0)) or just its subjectPublicKeyInfo
    (SPKI(1)).  The subjectPublicKeyInfo is an ASN.1 DER encoding
    of the certificate's algorithm id, any parameters and the public
    key data.
  </t>

  <t>
    The matching type field specifies how the TLSA RR Certificate
    Association Data field is to be compared with the certificate
    or public key.  A value of Full(0) means an exact match: the
    full DER encoding of the certificate or public key is given in
    the TLSA RR.  A value of SHA2-256(1) means that the association
    data matches the SHA2-256 digest of the certificate or public
    key, and likewise SHA2-512(2) means a SHA2-512 digest is used.
    Of the two digest algorithms, for now only SHA2-256(1) is mandatory
    to implement.  Clients SHOULD implement SHA2-512(2), but servers
    SHOULD NOT exclusively publish SHA2-512(2) digests.  The digest
    algorithm agility protocol defined in <xref target="agility"/>
    SHOULD be used by clients to decide how to process TLSA RRsets
    that employ multiple digest algorithms.  Server operators MUST
    publish TLSA RRsets that are compatible with digest algorithm
    agility.
  </t>

  <section title="Example TLSA record">
    <t>
      In the example TLSA record below:
    </t>

    <figure>
    <artwork>
_25._tcp.mail.example.com. IN TLSA 2 0 1 (
                           E8B54E0B4BAA815B06D3462D65FBC7C0
                           CF556ECCF9F5303EBFBB77D022F834C0 )
    </artwork>
    </figure>

    <t>
      The TLSA Certificate Usage is DANE-TA(2), the selector is
      Cert(0) and the matching type is SHA2-256(1).  The last field is
      the Certificate Association Data Field, which in this case
      contains the SHA2-256 digest of the server certificate.
    </t>

  </section><!-- Example TLSA record -->

</section><!-- DANE TLSA record overview -->

<section title="DANE TLS Requirements" anchor="tlsreq">

  <t>
    <xref target="RFC6698"/> does not discuss what versions of TLS are
    required when using DANE records.  This document specifies that
    TLS clients that support DANE/TLSA MUST support at least TLS 1.0
    and SHOULD support TLS 1.2.  TLS clients and servers using DANE
    SHOULD support the "Server Name Indication" (SNI) extension of
    TLS.
  </t>

</section><!-- TLS Requirements -->

<section title="DANE Certificate-Usage Selection Guidelines" anchor="pkixvsdane">

  <t>
    As mentioned in <xref target="overview" />, the TLSA certificate
    usage field takes one of four possible values.  With PKIX-TA(0)
    and PKIX-EE(1), the validation of peer certificate chains
    requires additional pre-configured CA trust anchors that are
    mutually trusted by the operators of the TLS server and client.
    With DANE-TA(2) and DANE-EE(3), no pre-configured CA trust
    anchors are required and the published DANE TLSA records are
    sufficient to verify the peer's certificate chain.
  </t>

  <t>
    Protocol designers should carefully consider which set of DANE
    certificate usages to support.  Simultaneous support for all
    four usages is NOT RECOMMENDED for DANE clients.  Protocol
    designers should either use the PKIX-TA(0) and PKIX-EE(1)
    certificate usages, or use the DANE-TA(2) and DANE-EE(3) usages.
    If all four usages are deployed together, an attacker capable of
    compromising the integrity of DNSSEC needs only to replace
    server's TLSA RRset with one that lists suitable DANE-EE(3) or
    DANE-TA(2) records, effectively bypassing the PKIX required
    checks.  In other words, when all four usages are supported,
    PKIX-TA(2) and PKIX-EE(1) offer only illusory incremental
    security.
  </t>

  <t>
    This document recommends that clients should generally support
    just the DANE-TA(2) and DANE-EE(3) certificate usages.  With
    DANE-TA(2) and DANE-EE(3) clients don't need to track a large
    changing list of X.509 trust-anchors.  Supporting PKIX-TA(0)
    or PKIX-EE(1) decreases the operational reliability of DANE-based
    authentication.
  </t>

  <t>
    The DNSSEC TLSA records for servers MAY include both sets of
    usages if the server needs to support a mixture of clients;
    some supporting one pair of usages and some the other.
  </t>

  <section title="Opportunistic Security and PKIX usages">

    <t>
      When the client's protocol design is based on Opportunistic
      Security (OS, <xref target="RFC7435"/>),
      and the use of authentication is based on the presence of
      server TLSA records, it is especially important to avoid the
      PKIX-EE(1) and PKIX-TA(0) certificate usages.  Since the
      presence and data integrity of TLSA records relies on DNSSEC,
      PKIX-TA(0) and PKIX-EE(1) TLSA records do not provide additional
      security.  With the PKIX-TA(0) and PKIX-EE(1) usages offering
      no more security, but being more prone to failure, they are
      a poor fit for opportunistic security and SHOULD NOT be used
      in that context.
    </t>

  </section><!-- Opportunistic Security and PKIX usages -->

  <section title="Interaction with Certificate Transparency">
  <!-- XXX: DANEbis: CT interaction: No CT for DANE-TA/EE -->

    <t>
      Certificate Transparency (CT) <xref target="RFC6962"/> defines
      an approach to mitigate the risk of rogue or compromised
      public CAs issuing unauthorized certificates.  This section
      clarifies the interaction of CT and DANE.
    </t>

    <t>
      When a server is authenticated via a DANE TLSA RR with TLSA
      Certificate Usage DANE-EE(3), the domain owner has directly
      specified the certificate associated with the given service
      without reference to any public certification authority.
      Therefore, when a TLS client authenticates the TLS server via
      a TLSA record with usage DANE-EE(3), CT checks SHOULD NOT be
      performed.  Publication of the server certificate or public
      key (digest) in a TLSA record in a DNSSEC signed zone by the
      domain owner assures the TLS client that the certificate is
      not an unauthorized certificate issued by a rogue CA without
      the domain owner's consent.
    </t>

    <t>
      When a server is authenticated via a DANE TLSA record with
      TLSA usage DANE-TA(2) and the server certificate does not
      chain to a known public root CA, CT cannot apply (CT logs
      only accept chains that start with a known, public root).
      Since TLSA Certificate Usage DANE-TA(2) is generally intended
      to support non-public trust anchors, TLS clients SHOULD NOT
      perform CT checks with usage DANE-TA(2).
    </t>

  </section> <!-- Interaction with Certificate Transparency -->

  <section title="Transitioning between PKIX-TA/EE and DANE-TA/EE">
    <t>
      The choice of preferred certificate usages may need to change
      as a protocol evolves.  When transitioning between PKIX-TA/PKIX-EE
      and DANE-TA/DANE-EE, clients begin to enable support for the
      new certificate usage values.  If the new preferred certificate
      usages are PKIX-TA/EE this requires installing and managing
      the appropriate set of CA trust anchors.  During this time
      servers will publish both types of TLSA records.  At some
      later time when the vast majority of servers have published
      the new preferred TLSA records, clients can stop supporting
      the legacy certificate usages.  Similarly, servers can stop
      publishing legacy TLSA records once the vast majority of
      clients support the new certificate usages.
    </t>

  </section><!-- Transitioning from PKIX-TA/EE to DANE-TA/EE -->

</section><!-- DANE Certificate-Usage Selection Guidelines -->

<section title="Certificate-Usage Specific DANE Updates and Guidelines">

  <t>
    The four Certificate Usage values from the TLSA record, DANE-EE(3),
    DANE-TA(2), PKIX-EE(1) and PKIX-TA(0), are discussed below.
  </t>

  <section title="Certificate Usage DANE-EE(3)" anchor="type3">

    <t>
      In this section the meaning of DANE-EE(3) is updated from
      <xref target="RFC6698"/> to specify that peer identity matching
      and that validity period enforcement is based solely on the
      TLSA RRset properties.  We also extend <xref target="RFC6698"/>
      to cover the use of DANE authentication of raw public keys
      <xref target="RFC7250"/> via TLSA records with Certificate
      Usage DANE-EE(3) and selector SPKI(1).
    </t>

    <t>
      Authentication via certificate usage DANE-EE(3) TLSA records
      involves simply checking that the server's leaf certificate
      matches the TLSA record.  In particular, the binding of the server
      public key to its name is based entirely on the TLSA record
      association.  The server MUST be considered authenticated even
      if none of the names in the certificate match the client's
      reference identity for the server.
    </t>

    <t>
      Similarly, with DANE-EE(3), the expiration date of the server
      certificate MUST be ignored. The validity period of the TLSA
      record key binding is determined by the validity period of
      the TLSA record DNSSEC signatures.
    </t>

    <t>
      With DANE-EE(3) servers that know all the connecting clients are
      making use of DANE, they need not employ SNI (i.e., the may
      ignore the client's SNI message) even when the server is known
      under multiple domain names that would otherwise require
      separate certificates.  It is instead sufficient for the TLSA
      RRsets for all the domain names in question to match the
      server's primary certificate.  For application protocols where
      the server name is obtained indirectly via SRV, MX or similar
      records, it is simplest to publish a single hostname as the
      target server name for all the hosted domains.
    </t>

    <t>
      In organizations where it is practical to make coordinated
      changes in DNS TLSA records before server key rotation, it is
      generally best to publish end-entity DANE-EE(3) certificate
      associations in preference to other choices of certificate
      usage.  DANE-EE(3) TLSA records support multiple server names
      without SNI, don't suddenly stop working when leaf or intermediate
      certificates expire, and don't fail when a server operator
      neglects to include all the required issuer certificates in
      the server certificate chain.
    </t>

    <t>
      TLSA records published for DANE servers SHOULD, as a best
      practice, be "DANE-EE(3) SPKI(1) SHA2-256(1)" records.  Since
      all DANE implementations are required to support SHA2-256, this
      record type works for all clients and need not change across
      certificate renewals with the same key.  This TLSA record type
      easily supports hosting arrangements with a single certificate
      matching all hosted domains.  It is also the easiest to implement
      correctly in the client.
    </t>

    <t>
      Another advantage of "DANE-EE(3) SPKI(1)" (with any suitable
      matching type) TLSA records is that they are compatible with
      the raw public key TLS extension specified in <xref
      target="RFC7250"/>.  DANE clients that support
      this extension can use the TLSA record to authenticate servers
      that negotiate the use of raw public keys in place of X.509
      certificate chains.  Provided the server adheres to the
      requirements of <xref target="rrreq"/>, the fact that raw
      public keys are not compatible with any other TLSA record
      types will not get in the way of successful authentication.
      Clients that employ DANE to authenticate the peer server
      SHOULD NOT negotiate the use of raw public keys unless
      the server's TLSA RRset includes compatible TLSA records.
    </t>

    <t>
      While it is, in principle, also possible to authenticate raw
      public keys via "DANE-EE(3) Cert(0) Full(0)" records by
      extracting the public key from the certificate in DNS, this
      is in conflict <!-- XXXWJH: state how; cause it doesn't require the
      full comparison of the full value I assume? -->
      with the indicated selector and requires extra
      logic on clients that not all implementations are expected to
      provide.  Servers SHOULD NOT rely on "DANE-EE(3) Cert(0)
      Full(0)" TLSA records to publish authentication data for raw
      public keys.
    </t>

  </section><!-- DANE-EE(3) -->

  <section title="Certificate Usage DANE-TA(2)" anchor="type2">

    <t>
      This section updates <xref target="RFC6698"/> by specifying
      a new operational requirement for servers publishing TLSA
      records with a usage of DANE-TA(2): such servers MUST include
      the trust-anchor certificate in their TLS server certificate
      message.
    </t>

    <t>
      Some domains may prefer to avoid the operational complexity
      of publishing unique TLSA RRs for each TLS service.  If the
      domain employs a common issuing Certification Authority to
      create certificates for multiple TLS services, it may be
      simpler to publish the issuing authority as a trust anchor
      (TA) for the certificate chains of all relevant services.
      The TLSA query domain (TLSA base domain with port and protocol
      prefix labels) for each service issued by the same TA may
      then be set to a CNAME alias that points to a common TLSA
      RRset that matches the TA.  For example:
    </t>

    <figure>
      <artwork>
www1.example.com.            IN A 192.0.2.1
www2.example.com.            IN A 192.0.2.2
_443._tcp.www1.example.com.  IN CNAME tlsa201._dane.example.com.
_443._tcp.www2.example.com.  IN CNAME tlsa201._dane.example.com.
tlsa201._dane.example.com.   IN TLSA 2 0 1 e3b0c44298fc1c14...
      </artwork>
    </figure>

    <t>
      With usage DANE-TA(2) the server certificates will need to
      have names that match one of the client's reference identifiers
      (see <xref target="RFC6125"/>).  The server SHOULD employ SNI
      to select the appropriate certificate to present to the client.
    </t>

    <section title="Recommended record combinations">

      <t>
	TLSA records with matching type Full(0) are NOT RECOMMENDED.  While
	these potentially obviate the need to transmit the TA certificate
	in the TLS server certificate message, client implementations
	may not be able to augment the server certificate chain with
	the data obtained from DNS, especially when the TLSA record
	supplies a bare key (selector SPKI(1)).  Since the server
	will need to transmit the TA certificate in any case, server
	operators SHOULD publish TLSA records with a matching type other
	than Full(0) and avoid potential DNS interoperability issues
	with large TLSA records containing full certificates or keys
	(see <xref target="sizeissues" />).
      </t>

      <t>
	TLSA Publishers employing DANE-TA(2) records SHOULD publish
	records with a selector of Cert(0).  Such TLSA records are
	associated with the whole trust anchor certificate, not just
	with the trust anchor public key.  In particular, the client
	SHOULD then apply any relevant constraints from the trust
	anchor certificate, such as, for example, path length
	constraints.
      </t>

      <t>
	While a selector of SPKI(1) may also be employed, the resulting
	TLSA record will not specify the full trust anchor certificate
	content, and elements of the trust anchor certificate other than
	the public key become mutable.  This may, for example, enable a
	subsidiary CA to issue a chain that violates the trust anchor's
	path length or name constraints.
      </t>

    </section><!-- Recommended record combinations -->

    <section title="Trust anchor digests and server certificate chain">

      <t>
	With DANE-TA(2), a complication arises when the TA certificate
	is omitted from the server's certificate chain, perhaps on
	the basis of Section 7.4.2 of <xref target="RFC5246"/>:
      </t>

      <figure>
	<artwork>
The sender's certificate MUST come first in the list.  Each
following certificate MUST directly certify the one preceding
it.  Because certificate validation requires that root keys be
distributed independently, the self-signed certificate that
specifies the root certification authority MAY be omitted from
the chain, under the assumption that the remote end must
already possess it in order to validate it in any case.
	</artwork>
      </figure>

      <t>
	With TLSA Certificate Usage DANE-TA(2), there is no expectation
	that the client is pre-configured with the trust anchor
	certificate.  In fact, client implementations are free to ignore all
	locally configured trust anchors when processing usage
	DANE-TA(2) TLSA records and may rely exclusively on the
	certificates provided in the server's certificate chain.
	But, with a digest in the TLSA record, the TLSA record contains
	neither the full trust anchor certificate nor the full public
	key.  If the TLS server's certificate chain does not contain
	the trust anchor certificate, DANE clients will be unable to
	authenticate the server.
      </t>

      <t>
	TLSA Publishers that publish TLSA Certificate Usage DANE-TA(2)
	associations with a selector of SPKI(1) or using a
	digest-based matching type (not Full(0)) MUST ensure that the
	corresponding server is configured to also include the trust
	anchor certificate in its TLS handshake certificate chain,
	even if that certificate is a self-signed root CA and would
	have been optional in the context of the existing public CA
	PKI.
      </t>

    </section><!-- "Trust anchor digests and server certificate chain" -->

    <!-- XXXWJH: I suggest we drop this whole section.  Above we
    specify that you MUST publish the root certificate in the TLS
    message.  If that's the case, we don't need to do the complex
    arguments described below.  Note that below it actually says
    "SHOULD" too, and above we say MUST.  We should only have one
    normative statement, and it should probably be the one above. -->
    <section title="Trust anchor public keys">

      <!-- XXX: DANEbis: clarify "IN TLSA 2 1 0" requirements. -->
      <t>
	TLSA records with TLSA Certificate Usage DANE-TA(2), selector
	SPKI(1) and a matching type of Full(0) will publish the full public
	key of a trust anchor via DNS.  In section 6.1.1 of <xref
	target="RFC5280"/> the definition of a trust anchor consists
	of the following four parts:
      </t>

      <t><list style="numbers">
	<t>the trusted issuer name,</t>
	<t>the trusted public key algorithm,</t>
	<t>the trusted public key, and</t>
	<t>optionally, the trusted public key parameters associated
	   with the public key.</t>
      </list></t>

      <t>
	Items 2&ndash;4 are precisely the contents of the subjectPublicKeyInfo
	published in the TLSA record.  The issuer name is not included
	in the subjectPublicKeyInfo.
      </t>

      <t>
	With TLSA Certificate Usage DANE-TA(2), the client may not
	have the associated trust anchor certificate, and cannot generally
	verify whether a particular certificate chain is "issued by"
	the trust anchor described in the TLSA record.
      </t>

      <t>
	When the server certificate chain includes a CA certificate
	whose public key matches the TLSA record, the client can
	match that CA as the intended issuer.  Otherwise, the client
	can only check that the topmost certificate in the server's
	chain is "signed by" the trust anchor's public key in the
	TLSA record.  Such a check may be difficult to implement,
	and cannot be expected to be supported by all clients.
      </t>

      <t>
	Thus, servers should not rely on "DANE-TA(2) SPKI(1) Full(0)"
	TLSA records to be sufficient to authenticate chains issued
	by the associated public key in the absence of a corresponding
	certificate in the server's TLS certificate message.  Servers
	SHOULD include the TA certificate in their certificate chain.
      </t>

      <t>
	If none of the server's certificate chain elements match a
	public key specified in a TLSA record, and at least
	one "DANE-TA(2) SPKI(1) Full(0)" TLSA record is available,
        clients are encouraged
	to check whether the topmost certificate in the chain is
	signed by the provided public key and has not expired, and
	in that case consider the server authenticated, provided
	the rest of the chain passes validation including leaf
	certificate name checks.
      </t>

    </section><!-- Trust anchor public keys -->

  </section><!-- DANE-TA(2) -->

  <section title="Certificate Usage PKIX-EE(1)" anchor="type1">

    <t>
      This Certificate Usage is similar to DANE-EE(3), but in
      addition PKIX verification is required.  Therefore, name
      checks, certificate expiration, etc., apply as they would
      without DANE.
    </t>

  </section><!-- PKIX-EE(1) -->

  <section title="Certificate Usage PKIX-TA(0)" anchor="type0">

    <t>
      This section updates <xref target="RFC6698"/> by specifying
      new client implementation requirements.  Clients that trust
      intermediate certificates MUST be prepared to construct longer
      PKIX chains than would be required for PKIX alone.
    </t>

    <t>
      TLSA Certificate Usage PKIX-TA(0) allows a domain to publish
      constraints on the set of PKIX certification authorities trusted
      to issue certificates for its TLS servers.  This TLSA record
      matches PKIX-verified trust chains which contain an issuer
      certificate (root or intermediate) that matches its association
      data field (typically a certificate or digest).
    </t>

    <t>
      PKIX-TA(0) also requires more complex coordination between the
      Customer Domain and the Service Provider in hosting
      arrangements.  Thus, this certificate usage is NOT RECOMMENDED
      when the Service Provider is not also the TLSA Publisher.
    </t>

    <t>
      TLSA Publishers who publish TLSA records for a particular
      public root CA, will expect that clients will only accept
      chains anchored at that root.  It is possible, however, that
      the client's trusted certificate store includes some intermediate
      CAs, either with or without the corresponding root CA.  When
      a client constructs a trust chain leading from a trusted
      intermediate CA to the server leaf certificate, such a
      "truncated" chain might not contain the trusted root published
      in the server's TLSA record.
    </t>

    <t>
      If the omitted root is also trusted, the client may erroneously
      reject the server chain if it fails to determine that the
      shorter chain it constructed extends to a longer trusted chain
      that matches the TLSA record.  Thus, when matching
      a usage PKIX-TA(0) TLSA record, a client SHOULD NOT always
      stop extending the chain when the first locally trusted
      certificate is found.  If no TLSA records have matched any
      of the elements of the chain, and the trusted certificate
      found is not self-issued, the client MUST attempt to build a
      longer chain in the hope that a certificate closer to the
      root may in fact match the server's TLSA record.
    </t>

  </section><!-- PKIX-TA(0) -->

</section><!-- Certificate-Usage-specific DANE updates and guidelines -->

<section title="Service Provider and TLSA Publisher Synchronization"
    anchor="sync">

  <t>
    Complications arise when the TLSA Publisher is not the same
    entity as the Service Provider.  In this situation, the TLSA
    Publisher and the Service Provider must cooperate to ensure that
    TLSA records published by the TLSA Publisher don't fall out of
    sync with the server certificate used by the
    Service Provider.
  </t>

  <t>
    <!-- XXX: DANEbis: Explain how DANE-EE(3) and DANE-TA(2) make it
     it possible to avoid the need for service providers to obtain keys
     from clients, or alternatively for clients to publish TLSA RRs
     for provider generated keys. SNI is needed with DANE-TA(2), but
     the key material and TLSA RRs are managed unilaterally by the
     Service Provider. -->
    Whenever possible, the TLSA Publisher and the Service Provider
    should be the same entity.  Otherwise, changes in the service
    certificate chain must be carefully coordinated between the
    parties involved.  Such coordination is difficult and service
    outages will result when coordination fails.
  </t>

  <t>
    Having the master TLSA record in the Service Provider's zone
    avoids the complexity of bilateral coordination of server
    certificate configuration and TLSA record management.  Even
    when the TLSA RRset must be published in the Customer Domain's
    DNS zone (perhaps the client application does not "chase" CNAMEs
    to the TLSA base domain), it is possible to employ CNAME
    records to delegate the content of the TLSA RRset to a domain
    operated by the Service Provider.  Certificate name checks
    generally constrain the applicability of TLSA CNAMEs across
    organizational boundaries to Certificate Usages DANE-EE(3) and
    DANE-TA(2):
  </t>

  <t>
  <list style="hanging">

  <t hangText="Certificate Usage DANE-EE(3):"> In this case the
  Service Provider can publish a single TLSA RRset that matches the
  server certificate or public key digest.  The same RRset works for
  all Customer Domains because name checks do not apply with
  DANE-EE(3) TLSA records (see <xref target="type3" />).  A
  Customer Domain can create a CNAME record pointing to the TLSA
  RRset published by the Service Provider.  </t>

  <t hangText="Certificate Usage DANE-TA(2):"> When the Service
  Provider operates a private certification authority, the Service
  Provider is free to issue a certificate bearing any customer's
  domain name.  Without DANE, such a certificate would not pass
  trust verification, but with DANE, the customer's TLSA RRset that
  is aliased to the provider's TLSA RRset can delegate authority to
  the provider's CA for the corresponding service.  The Service
  Provider can generate appropriate certificates for each customer
  and use the SNI information provided by clients to select the
  right certificate chain to present to each client.  </t>

  </list>
  </t>

  <t>
    Below are example DNS records (assumed "secure" and shown without
    the associated DNSSEC information, such as record signatures)
    that illustrate both of of the above models in the case of an
    HTTPS service whose clients all support DANE TLS.  These examples
    work even with clients that don't "chase" CNAMEs when constructing
    the TLSA base domain (see <xref target="cname"/> below).
  </t>

  <figure>
  <artwork>
; The hosted web service is redirected via a CNAME alias.
; The associated TLSA RRset is also redirected via a CNAME alias.
;
; A single certificate at the provider works for all Customer
; Domains due to the use of the DANE-EE(3) Certificate Usage.
;
www1.example.com.            IN CNAME w1.example.net.
_443._tcp.www1.example.com.  IN CNAME _443._tcp.w1.example.net.
_443._tcp.w1.example.net.    IN TLSA 3 1 1 (
                                8A9A70596E869BED72C69D97A8895DFA
                                D86F300A343FECEFF19E89C27C896BC9 )

;
; A CA at the provider can also issue certificates for each Customer
; Domain, and use the DANE-TA(2) Certificate Usage type to
; indicate a trust anchor.
;
www2.example.com.            IN CNAME w2.example.net.
_443._tcp.www2.example.com.  IN CNAME _443._tcp.w2.example.net.
_443._tcp.w2.example.net.    IN TLSA 2 0 1 (
                                C164B2C3F36D068D42A6138E446152F5
                                68615F28C69BD96A73E354CAC88ED00C )
  </artwork>
  </figure>

  <t>
    <!-- XXX: DANEbis: Note redirection of TLSA base domain via MX, SRV
    and related records -->
    With protocols that support explicit transport redirection
    via DNS MX records, SRV records, or other similar records,
    the TLSA base domain is based on the redirected transport
    end-point, rather than the origin domain.  With SMTP, for
    example, when an email service is hosted by a Service Provider,
    the Customer Domain's MX hostnames will point at the Service
    Provider's SMTP hosts.  When the Customer Domain's DNS zone
    is signed, the MX hostnames can be securely used as the base
    domains for TLSA records that are published and managed by the
    Service Provider.  For example (without the required DNSSEC
    information, such as record signatures):
  </t>

  <figure>
  <artwork>
; Hosted SMTP service
;
example.com.               IN MX 0 mx1.example.net.
example.com.               IN MX 0 mx2.example.net.
_25._tcp.mx1.example.net.  IN TLSA 3 1 1 (
                              8A9A70596E869BED72C69D97A8895DFA
                              D86F300A343FECEFF19E89C27C896BC9 )
_25._tcp.mx2.example.net.  IN TLSA 3 1 1 (
                              C164B2C3F36D068D42A6138E446152F5
                              68615F28C69BD96A73E354CAC88ED00C )
  </artwork>
  </figure>

  <t>
    If redirection to the Service Provider's domain (via MX or SRV
    records or any similar mechanism) is not possible, and aliasing
    of the TLSA record is not an option, then more complex coordination
    between the Customer Domain and Service Provider will be required.
    Either the Customer Domain periodically provides private keys
    and a corresponding certificate chain to the Provider (after
    making appropriate changes in its TLSA records), or the Service
    Provider periodically generates the keys and certificates and
    must wait for matching TLSA records to be published by its
    Customer Domains before deploying newly generated keys and
    certificate chains.  In <xref target="cname"/> below, we describe
    an approach that employs CNAME "chasing" to avoid the difficulties
    of coordinating key management across organization boundaries.
  </t>

  <t>
    For further information about combining DANE and SRV, please
    see <xref target="I-D.ietf-dane-srv" />.
  </t>

</section><!-- Service Provider and TLSA Publisher Synchronization -->

<section title="TLSA Base Domain and CNAMEs" anchor="cname">

  <t>
    When the application protocol does not support service location
    indirection via MX, SRV or similar DNS records, the service may be
    redirected via a CNAME.  A CNAME is a more blunt instrument
    for this purpose, since unlike an MX or SRV record, it remaps
    the entire origin domain to the target domain for all protocols.
  </t>

  <t>
    <!-- XXX: DANEbis: Preferred TLSA base domain with CNAME expansion -->
    The complexity of coordinating key management is largely
    eliminated when DANE TLSA records are found in the Service
    Provider's domain, as discussed in <xref target="sync" />.
    Therefore, DANE TLS clients connecting to a server whose domain
    name is a CNAME alias SHOULD follow the CNAME hop-by-hop to its
    ultimate target host (noting at each step whether the CNAME is
    DNSSEC-validated).  If at each stage of CNAME expansion the
    DNSSEC validation status is "secure", the final target name
    SHOULD be the preferred base domain for TLSA lookups.
  </t>

  <t>
    <!-- XXX: DANEbis: Fallback TLSA base domain with CNAME expansion -->
    Implementations failing to find a TLSA record using a base
    name of the final target of a CNAME expansion SHOULD issue a
    TLSA query using the original destination name.  That is, the
    preferred TLSA base domain should be derived from the
    fully expanded name, and failing that should be the initial
    domain name.
  </t>

  <t>
    When the TLSA base domain is the result of "secure" CNAME
    expansion, the resulting domain name MUST be used as the HostName
    in SNI, and MUST be the primary reference identifier for peer
    certificate matching with certificate usages other than DANE-EE(3).
  </t>

  <t>
    Protocol-specific TLSA specifications may provide additional
    guidance or restrictions when following CNAME expansions.
  </t>

  <t>
    Though CNAMEs are illegal on the right hand side of most
    indirection records, such as MX and SRV records, they are
    supported by some implementations.  For example, if the MX or
    SRV host is a CNAME alias, some implementations may "chase" the
    CNAME.  If they do, they SHOULD use the target hostname as the
    preferred TLSA base domain as described above (and if the TLSA
    records are found there, use the CNAME expanded domain also in
    SNI and certificate name checks).
  </t>

</section><!-- TLSA Base Domain and CNAMEs -->

<section title="TLSA Publisher Requirements" anchor="rrreq">

  <t>
    This section updates <xref target="RFC6698"/> by specifying a
    requirement on the TLSA Publisher to ensure that each combination
    of Certificate Usage, selector and matching type in the server's
    TLSA RRset MUST include at least one record that matches the
    server's current certificate chain.  TLSA records that match
    recently retired or yet to be deployed certificate chains will
    be present during key rollover.  Such past or future records
    must never be the only records published for any given combination
    of usage, selector and matching type.  We describe a TLSA record
    update algorithm that ensures this requirement is met.
  </t>

  <t>
    While a server is to be considered authenticated when its
    certificate chain is matched by any of the published TLSA
    records, not all clients support all combinations of TLSA record
    parameters.  Some clients may not support some digest algorithms,
    others may either not support, or may exclusively support, the
    PKIX Certificate Usages.  Some clients may prefer to negotiate
    <xref target="RFC7250"/> raw public keys, which
    are only compatible with TLSA records whose Certificate Usage is
    DANE-EE(3) with selector SPKI(1).
  </t>

  <t>
    A consequence of the above uncertainty as to which TLSA parameters
    are supported by any given client is that servers need to ensure that
    each and every parameter combination that appears in the TLSA RRset
    is, on its own, sufficient to match the server's current certificate
    chain.  In particular, when deploying new keys or new parameter
    combinations some care is required to not generate parameter
    combinations that only match past or future certificate chains
    (or raw public keys).  The rest of this section explains how to
    update the TLSA RRset in a manner that ensures the above requirement
    is met.
  </t>

<section title="Key rollover with fixed TLSA Parameters" anchor="rollkey">

  <t>
     The simplest case is key rollover while retaining the same set
     of published parameter combinations.  In this case, TLSA records
     matching the existing server certificate chain (or raw public
     keys) are first augmented with corresponding records matching
     the future keys, at least two TTLs or longer before
     the the new chain is deployed.  This allows the obsolete RRset
     to age out of client caches before the new chain is used in
     TLS handshakes.  Once sufficient time has elapsed and all
     clients performing DNS lookups are retrieving the updated TLSA records,
     the server administrator may deploy the new certificate chain,
     verify that it works, and then remove any obsolete
     records matching the no longer active chain:
  </t>

  <figure>
    <artwork>
; The initial TLSA RRset
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...

; The transitional TLSA RRset published at least 2*TTL seconds
; before the actual key change
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...

; The final TLSA RRset after the key change
;
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...
    </artwork>
  </figure>

  <t>
     The next case to consider is adding or switching to a new
     combination of TLSA parameters.  In this case publish the new
     parameter combinations for the server's existing certificate
     chain first, and only then deploy new keys if desired:
  </t>

  <figure>
    <artwork>
; Initial TLSA RRset
;
_443._tcp.www.example.org. IN TLSA 1 1 1 01d09d19c2139a46...

; New TLSA RRset, same key re-published as DANE-EE(3)
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
    </artwork>
  </figure>

</section><!-- Rolling a Key Without Changing TLSA Parameters -->
<section title="Switching to DANE-TA from DANE-EE">

  <t>
     A more complex involves switching to a trust-anchor or PKIX
     usage from a chain that is either self-signed, or issued by
     a private CA and thus not compatible with PKIX.  Here the
     process is to first add TLSA records matching the future
     chain that is issued by the desired future CA (private or
     PKIX), but initially with the same parameters as the legacy
     chain.  Then, after deploying the new keys, switch to the
     new TLSA parameter combination.
  </t>

  <figure>
    <artwork>
; The initial TLSA RRset
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...

; A transitional TLSA RRset, published at least 2*TTL before the
; actual key change.  The new keys are issued by a DANE-TA(2) CA,
; but for now specified via a DANE-EE(3) association.
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...

; The final TLSA RRset after the key change.  Now that the old
; self-signed EE keys are not an impediment, specify the issuing
; TA of the new keys.
;
_443._tcp.www.example.org. IN TLSA 2 0 1 c57bce38455d9e3d...
    </artwork>
  </figure>
</section>

<section title="Switching to New TLSA Parameters">
  <t>
    When employing a new digest algorithm in the TLSA RRset, for
    compatibility with digest agility specified in <xref
    target="agility"/> below, administrators should publish the new
    digest algorithm with each combinations of Certificate Usage and
    selector for each associated key or chain used with any other
    digest algorithm.  When removing an algorithm, remove it entirely.
    Each digest algorithm employed should match the same set of chains
    (or raw public keys).
  </t>

  <figure>
    <artwork>
; The initial TLSA RRset with EE SHA2-256 associations for two keys.
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...

; The new TLSA RRset also with SHA2-512 associations for each key
;
_443._tcp.www.example.org. IN TLSA 3 1 1 01d09d19c2139a46...
_443._tcp.www.example.org. IN TLSA 3 1 2 d9947c35089310bc...
_443._tcp.www.example.org. IN TLSA 3 1 1 7aa7a5359173d05b...
_443._tcp.www.example.org. IN TLSA 3 1 2 89a7486a4b6ae714...
    </artwork>
  </figure>
</section><!-- Switching to new TLSA Parameters -->

<section title="TLSA Publisher Requirements Summary">

  <t>
    In summary, server operators updating TLSA records should make
    one change at a time.  The individual safe changes are:

    <list style="symbols">
      <t> Pre-publish new certificate associations that employ the
      same TLSA parameters (usage, selector and matching type) as
      existing TLSA records, but match certificate chains that will
      be deployed in the near future.  Wait for stale TLSA RRsets
      to expire from DNS caches before configuring servers to use
      the new certificate chain. </t>

      <t> Remove TLSA records matching no longer deployed certificate
      chains. </t>

      <t> Extend the TLSA RRset with a new combination of parameters
      (usage, selector and matching type) that is used to generate
      matching associations for all certificate chains that are
      published with some other parameter combination. </t>
    </list>

    The above steps are intended to ensure that at all times and
    for each combination of usage, selector and matching type at
    least one TLSA record corresponds to the server's current
    certificate chain.  No combination of Certificate Usage, selector
    and matching type in a server's TLSA RRset should ever match
    only some combination of future or past certificate chains.
    As a result, no matter what combinations of usage, selector
    and matching type may be supported by a given client, they
    will be sufficient to authenticate the server.
  </t>

</section><!-- TLSA RRset Best Practice Summary -->

</section><!-- TLSA RRset best pracice -->

<section title="Digest Algorithm Agility" anchor="agility">

<t>
  While <xref target="RFC6698"/> specifies multiple digest algorithms,
  it does not specify a protocol by which the client and TLSA record
  publisher can agree on the strongest shared algorithm.  Such a
  protocol would allow the client and server to avoid exposure to
  deprecated weaker algorithms that are published for compatibility
  with less capable clients, but which SHOULD be avoided when
  possible.  We specify such a protocol below.
</t>

<t>
  This section defines a protocol for avoiding deprecated digest
  algorithms when these are published in a peer's TLSA RRset alongside
  stronger digest algorithms.  Note that this protocol never avoids
  RRs with DANE matching type Full(0), as these do not employ a
  digest algorithm that might some day be weakened by cryptanalysis.
</t>

<t>
  Client implementations SHOULD implement a default order of digest
  algorithms by strength.  This order SHOULD be configurable by the
  MTA administrator.  If possible, a configurable mapping from
  numeric DANE TLSA matching types to underlying digest algorithms
  provided by the cryptographic library SHOULD be implemented to
  allow new matching types to be used with software that predates
  their introduction.  Configurable ordering of digest algorithms
  SHOULD be extensible to any new digest algorithms.
</t>

<t>
  To make digest algorithm agility possible, all published DANE
  TLSA RRsets MUST conform to the requirements of <xref target="rrreq"/>.
  Clients SHOULD use digest algorithm agility when processing the
  peer's DANE TLSA records.  Algorithm agility is to be applied
  after first discarding any unusable or malformed records (unsupported
  digest algorithm, or incorrect digest length).  For each usage
  and selector, the client SHOULD process only any usable records
  with a matching type of Full(0) and the usable records whose
  digest algorithm is considered by the client to be the strongest
  among usable records with the given usage and selector.
</t>

<t>
  Example: a client implements digest agility and prefers SHA2-512(2)
  over SHA2-256(1), while the server publishes an RRset that employs
  both digest algorithms as well as a Full(0) record.
</t>

  <figure>
  <artwork>
_25._tcp.mail.example.com. IN TLSA 3 1 1 (
                              3FE246A848798236DD2AB78D39F0651D
			      6B6E7CA8E2984012EB0A2E1AC8A87B72 )
_25._tcp.mail.example.com. IN TLSA 3 1 2 (
                              D4F5AF015B46C5057B841C7E7BAB759C
			      BF029526D29520C5BE6A32C67475439E
			      54AB3A945D80C743347C9BD4DADC9D8D
			      57FAB78EAA835362F3CA07CCC19A3214 )
_25._tcp.mail.example.com. IN TLSA 3 1 0 (
                              3059301306072A8648CE3D020106082A
			      8648CE3D0301070342000471CB1F504F
			      9E4B33971376C005445DACD33CD79A28
			      81C3DED1981F18E7AAA76609DD0E4EF2
			      8265C82703030AD60C5DBA6FB8A9397A
			      C0FCF06D424C885D484887 )
  </artwork>
  </figure>

<t>
  In this case the client SHOULD accept a server public key that
  matches either the "3 1 0" record or the "3 1 2" record, but
  SHOULD not accept keys that match only the weaker "3 1 1" record.
</t>

</section><!-- Digest algorithm agility -->

<section title="General DANE Guidelines">

  <t>
    These guidelines provide guidance for using or designing protocols
    for DANE.
  </t>

  <section title="DANE DNS Record Size Guidelines" anchor="dns">

    <t>
      Selecting a combination of TLSA parameters to use requires
      careful thought.  One important consideration to take into
      account is the size of the resulting TLSA record after its
      parameters are selected.
    </t>

    <section title="UDP and TCP Considerations" anchor="sizeissues">

      <t>
        Deployments SHOULD avoid TLSA record sizes that cause UDP
        fragmentation.
      </t>

      <t>
        Although DNS over TCP would provide the ability to more easily
        transfer larger DNS records between clients and servers, it is
        not universally deployed and is still prohibited by some
        firewalls.  Clients that request DNS records via UDP typically
        only use TCP upon receipt of a truncated response in the DNS
        response message sent over UDP.  Setting the TC bit alone will
        be insufficient if the response containing the TC bit is
        itself fragmented.
      </t>

    </section>

    <!-- XXX: DANEbis: Discourage use of Full(0) -->
    <section title= "Packet Size Considerations for TLSA Parameters">

      <t>
        Server operators SHOULD NOT publish TLSA records using both a
        TLSA Selector of Cert(0) and a TLSA Matching Type of Full(0),
        as even a single certificate is generally too large to be
        reliably delivered via DNS over UDP.  Furthermore, two TLSA
        records containing full certificates will need to be published
        simultaneously during a certificate rollover, as discussed in
        <xref target="rollkey" />.
      </t>

      <t>
        While TLSA records using a TLSA Selector of SPKI(1) and a TLSA
        Matching Type of Full(0) (which publish the bare public keys without
	the overhead of a containing X.509 certificate) are generally more
	compact, these too should be used with caution as they are still
	larger than necessary.  Rather, servers SHOULD publish digest-based
	TLSA Matching Types in their TLSA records.
        The complete corresponding certificate should, instead, be
        transmitted to the client in-band during the TLS handshake,
        which can be easily verified using the digest value.
      </t>

      <t>
        In summary, the use of a TLSA Matching Type of Full(0) is NOT
        RECOMMENDED and the use of a digest-based matching type, such
        as SHA2-256(1) SHOULD be used.
      </t>

    </section>

  </section>

  <section title="Certificate Name Check Conventions" anchor="namechecks">

    <t>
      Certificates presented by a TLS server will generally contain a
      subjectAltName (SAN) extension or a Common Name (CN) element within
      the subject distinguished name (DN).  The TLS server's DNS domain name
      is normally published within these elements, ideally within the
      subjectAltName extension. (The use of the CN field for this purpose
      is deprecated.)
    </t>

    <t>
      <!-- XXX: DANEbis: Mandate use of SNI by clients -->
      When a server hosts multiple domains at the same transport
      endpoint, the server's ability to respond with the right
      certificate chain is predicated on correct SNI information
      from the client.  DANE clients MUST send the SNI extension
      with a HostName value of the base domain of the TLSA RRset.

      <!-- XXXWJH: but if we select the base name as the original name
           because of dnssec failures in the middle, then this won't
           work.  Consider a type 3 cert, where we fall back to the
           initial name because of broken middle-ness.  But the server
           is still expecting the final name, and may return some
           other random cert if it doesn't know the initial name. IE, The
           client will send one of two SNI values and the server may
           only understand one and may return a default cert that
           matches neither.  If they had requested the final name and
           it worked, the type3 local tlsa could still match.  This is
           not really a suggested solution, just thinking outloud about
           problems. -->
    </t>

    <t>
      <!-- XXX: DANEbis: Specify name check requirements -->
      Except with TLSA Certificate Usage DANE-EE(3), where name
      checks are not applicable (see <xref target="type3" />), DANE
      clients MUST verify that the client has reached the correct
      server by checking that the server name is listed in the
      server certificate's SAN or CN.  The server name used for this comparison
      SHOULD be the base domain of the TLSA RRset.  Additional
      acceptable names may be specified by protocol-specific DANE
      standards.  For example, with SMTP both the destination domain
      name and the MX host name are acceptable names to be found
      in the server certificate (see <xref
      target="I-D.ietf-dane-smtp-with-dane"/>).
    </t>

    <t>
      It is the responsibility of the service operator, in
      coordination with the TLSA Publisher, to ensure that at least
      one of the TLSA records published for the service will match the
      server's certificate chain (either the default chain or the
      certificate that was selected based on the SNI information
      provided by the
      client).
    </t>

    <t>
      Given the DNSSEC validated DNS records below:
    </t>

    <figure>
      <artwork>
example.com.               IN MX 0 mail.example.com.
mail.example.com.          IN A 192.0.2.1
_25._tcp.mail.example.com. IN TLSA 2 0 1 (
                              E8B54E0B4BAA815B06D3462D65FBC7C0
                              CF556ECCF9F5303EBFBB77D022F834C0 )
      </artwork>
    </figure>

    <t>
      The TLSA base domain is "mail.example.com" and is required
      to be the HostName in the client's SNI extension.  The server
      certificate chain is required to be be signed by a trust
      anchor with the above certificate SHA2-256 digest.  Finally,
      one of the DNS names in the server certificate is required
      to be be either "mail.example.com" or "example.com" (this
      additional name is a concession to compatibility with prior
      practice, see <xref target="I-D.ietf-dane-smtp-with-dane"/>
      for details).
    </t>

    <t>
      The semantics of wildcards in server certificates are left to
      individual application protocol specifications.
      <!-- seems like a cop-out without stating why -->
    </t>

  </section><!-- Certificate Name Check Conventions -->

  <section title="Design Considerations for Protocols Using DANE">

    <t>
      When a TLS client goes to the trouble of authenticating a
      certificate chain presented by a TLS server, it will typically
      not continue to use that server in the event of authentication
      failure, or else authentication serves no purpose.  Some
      clients may, at times, operate in an "audit" mode, where
      authentication failure is reported to the user or in logs as
      a potential problem, but the connection proceeds despite the
      failure.  Nevertheless servers publishing TLSA records MUST
      be configured to allow correctly configured clients to
      successfully authenticate their TLS certificate chains.
    </t>

    <!-- XXX: DANEbis: Opportunistic TLS discovery. -->
    <t>
      <!-- XXXWJH: Err....  I'm not sure we can say this generically;
           smtp, sure, but I'm not sure the WG agreed to it completely -->
      <!-- XXXWJH: this defines unusable to include broken hashes??? -->
      A service with DNSSEC-validated TLSA records implicitly promises
      TLS support.  When all the TLSA records for a service are found
      "unusable", due to unsupported parameter combinations or
      malformed associated data, DANE clients cannot authenticate the
      service certificate chain.  When authenticated TLS is dictated
      by the application, the client SHOULD NOT connect to the
      associated server.  If, on the other hand, the use of TLS is
      "opportunistic", then the client SHOULD generally use the server
      via an unauthenticated TLS connection, but if TLS encryption
      cannot be established, the client MUST NOT use the server.
      Standards for DANE specific to the particular application
      protocol may modify the above requirements, as appropriate, to
      specify whether the connection should be established anyway
      without relying on TLS security, with only encryption but not
      authentication, or whether to refuse to connect entirely.
      Application protocols need to specify when to prioritize
      security over the ability to connect under adverse conditions.
    </t>

  </section><!-- Design Considerations for Protocols Using DANE -->

</section>

<section title="Note on DNSSEC Security">

  <t>
    Clearly the security of the DANE TLSA PKI rests on the security
    of the underlying DNSSEC infrastructure.  While this document is
    not a guide to DNSSEC security, a few comments may be helpful
    to TLSA implementers.
  </t>

  <t>
    With the existing public CA PKI, name constraints are rarely used,
    and a public root CA can issue certificates for any domain of its
    choice.  With DNSSEC, under the Registry/Registrar/Registrant
    model, the situation is different: only the registrar of record
    can update a domain's DS record in the registry parent zone (in
    some cases, however, the registry is the sole registrar).  With
    many gTLDs, for which multiple registrars compete to provide
    domains in a single registry, it is important to make sure that
    rogue registrars cannot easily initiate an unauthorized domain
    transfer, and thus take over DNSSEC for the domain.  DNS Operators
    SHOULD use a registrar lock of their domains to offer some
    protection against this possibility.
  </t>

  <t>
    When the registrar is also the DNS operator for the domain, one
    needs to consider whether the registrar will allow orderly
    migration of the domain to another registrar or DNS operator
    in a way that will maintain DNSSEC integrity.  TLSA Publishers
    SHOULD ensure their registrar publishes a suitable domain
    transfer policy.
  </t>

  <t>
    DNSSEC signed RRsets cannot be securely revoked before they
    expire.  Operators should plan accordingly and not generate
    signatures with excessively long duration periods.  For domains publishing
    high-value keys, a signature lifetime of a few days is reasonable,
    and the zone should be resigned daily.  For domains with
    less critical data, a reasonable signature lifetime is a couple
    of weeks to a month, and the zone should be resigned weekly.
    Monitoring of the signature lifetime is important.  If the zone
    is not resigned in a timely manner, one risks a major outage
    and the entire domain will become bogus.
  </t>

</section>

<section title="Summary of Updates to RFC6698" anchor="updates">

  <t>Authors note: is this section needed?  Or is it sufficiently
  clear above that we don't need to restate things here?</t>

  <t>
    <list style="symbols">

    <t>In <xref target="tlsreq"/> we update <xref target="RFC6698"/>
    to specify a requirement for clients to support at least TLS
    1.0, and to support SNI. </t>

    <t>In <xref target="type3"/> we update <xref target="RFC6698"/>
    to specify peer identity matching and certificate validity
    interval based solely on the basis of the TLSA RRset.  We also
    specify DANE authentication of raw public keys <xref
    target="RFC7250"/> via TLSA records with
    Certificate Usage DANE-EE(3) and selector SPKI(1). </t>

    <t>In <xref target="type2"/> we update <xref target="RFC6698"/>
    to require that servers publishing digest TLSA records with a
    usage of DANE-TA(2) MUST include the trust-anchor certificate
    in their TLS server certificate message.  This extends to the
    case of "2 1 0" TLSA records which publish a full public key. </t>

    <t>In <xref target="type1"/> and <xref target="type0"/>, we explain
    that PKIX-EE(1) and PKIX-TA(0) are generally NOT RECOMMENDED.
    With usage PKIX-TA(0) we note that clients may need to processes
    extended trust chains beyond the first trusted issuer, when
    that issuer is not self-signed. </t>

    <t> In <xref target="cname"/>, we recommend that DANE application
    protocols specify that when possible securely CNAME expanded names
    be used to derive the TLSA base domain. </t>

    <t> In <xref target="rrreq"/>, we specify a strategy for managing
    TLSA records that interoperates with DANE clients regardless
    of what subset of the possible TLSA record types (combinations
    of TLSA parameters) is supported by the client. </t>

    <t> In <xref target="agility"/>, we specify a digest algorithm
    agility protocol. </t>

    <t> In <xref target="dns"/> we recommend against the use of
    Full(0) TLSA records, as digest records are generally much more
    compact. </t>

    </list>
  </t>

</section><!-- Summary of RFC6698 updates -->

<section anchor="ops" title="Operational Considerations">

  <t>
    The DNS time-to-live (TTL) of TLSA records needs to be chosen
    with care.  When an unplanned change in the server's certificate
    chain and TLSA RRset is required, such as when keys are compromised
    or lost, clients that cache stale TLSA records will fail to
    validate the certificate chain of the updated server.  TLSA
    RRsets should have TTLs that are short enough to limit unplanned
    service disruption to an acceptable duration.
  </t>

  <t>
    The signature validity period for TLSA records should also not
    be too long.  Signed DNSSEC records can be replayed by an MiTM
    attacker provided the signatures have not yet expired.  Shorter
    signature validity periods allow for faster invalidation of
    compromised keys.  Zone refresh and expiration times for secondary
    nameservers often imply a lower bound on the signature validity
    period.  See Section 4.4.1 of <xref target="RFC6781"/>.
  </t>

</section><!-- Operational Considerations -->

<section anchor="Security" title="Security Considerations">

  <!-- XXXWJH: this section seems a bit weak and short, considering
  the security ramifications of everything being discussed -->
  <t>
    Application protocols that cannot make use of the existing public
    CA PKI (so called non-PKIX protocols), may choose not to implement
    certain PKIX-dependent TLSA record types defined in <xref
    target="RFC6698"/>.  If such records are published despite
    not being supported by the application protocol, they are treated as
    "unusable".  When TLS is opportunistic, the client may proceed
    to use the server with mandatory unauthenticated TLS.  This is stronger
    than opportunistic TLS without DANE, since in that case the client
    may also proceed with a plaintext connection.  When TLS is not
    opportunistic, the client MUST NOT connect to the server.
  </t>

  <t>
    Therefore, when TLSA records are used with protocols where PKIX
    does not apply, the recommended policy is for servers to not
    publish PKIX-dependent TLSA records, and for opportunistic TLS
    clients to use them to enforce the use of (albeit unauthenticated)
    TLS, but otherwise treat them as unusable.  Of course, when PKIX
    validation is supported by the application protocol, clients
    SHOULD perform PKIX validation per <xref target="RFC6698"/>.
  </t>

</section><!-- Security Considerations -->

<section title="IANA Considerations">
  <t>This specification requires no support from IANA.</t>
</section>

<section anchor="Acknowledgements" title="Acknowledgements">

  <t>
    The authors would like to thank Phil Pennock for his comments and
    advice on this document.
  </t>

  <t>
    Acknowledgments from Viktor: Thanks to Tony Finch who finally
    prodded me into participating in DANE working group discussions.
    Thanks to Paul Hoffman who motivated me to produce this document
    and provided feedback on early drafts.  Thanks also to Samuel
    Dukhovni for editorial assistance.
  </t>

</section><!-- Acknowledgements -->

</middle>

<back>
<references title="Normative References">
&RFC2119;
&RFC4033;
&RFC4034;
&RFC4035;
&RFC5246;
&RFC5280;
&RFC6066;
&RFC6125;
&RFC6347;
&RFC6698;
&RFC7218;
</references>
<references title="Informative References">
&RFC6781;
&RFC6962;
&RFC7250;
&RFC7435;
&I-D.ietf-dane-smtp-with-dane;
&I-D.ietf-dane-srv;
</references>
</back>
</rfc>
